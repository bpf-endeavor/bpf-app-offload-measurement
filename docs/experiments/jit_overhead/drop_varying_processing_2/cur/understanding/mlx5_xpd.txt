
./xdp.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <mlx5_real_time_cyc2time-0x10>:
       0:	90                   	nop
       1:	90                   	nop
       2:	90                   	nop
       3:	90                   	nop
       4:	90                   	nop
       5:	90                   	nop
       6:	90                   	nop
       7:	90                   	nop
       8:	90                   	nop
       9:	90                   	nop
       a:	90                   	nop
       b:	90                   	nop
       c:	90                   	nop
       d:	90                   	nop
       e:	90                   	nop
       f:	90                   	nop

0000000000000010 <mlx5_real_time_cyc2time>:

#define REAL_TIME_TO_NS(hi, low) (((u64)hi) * NSEC_PER_SEC + ((u64)low))

static inline ktime_t mlx5_real_time_cyc2time(struct mlx5_clock *clock,
					      u64 timestamp)
{
      10:	f3 0f 1e fa          	endbr64 
	u64 time = REAL_TIME_TO_NS(timestamp >> 32, timestamp & 0xFFFFFFFF);
      14:	48 89 f0             	mov    %rsi,%rax
      17:	89 f6                	mov    %esi,%esi
      19:	48 c1 e8 20          	shr    $0x20,%rax
      1d:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
      24:	48 01 f0             	add    %rsi,%rax

	return ns_to_ktime(time);
}
      27:	e9 00 00 00 00       	jmp    2c <mlx5_real_time_cyc2time+0x1c>
      2c:	0f 1f 40 00          	nopl   0x0(%rax)
      30:	90                   	nop
      31:	90                   	nop
      32:	90                   	nop
      33:	90                   	nop
      34:	90                   	nop
      35:	90                   	nop
      36:	90                   	nop
      37:	90                   	nop
      38:	90                   	nop
      39:	90                   	nop
      3a:	90                   	nop
      3b:	90                   	nop
      3c:	90                   	nop
      3d:	90                   	nop
      3e:	90                   	nop
      3f:	90                   	nop

0000000000000040 <mlx5e_xsk_request_checksum>:

	return  mlx5_timecounter_cyc2time(&priv->cq->mdev->clock, ts);
}

static void mlx5e_xsk_request_checksum(u16 csum_start, u16 csum_offset, void *priv)
{
      40:	f3 0f 1e fa          	endbr64 
      44:	e8 00 00 00 00       	call   49 <mlx5e_xsk_request_checksum+0x9>
      49:	55                   	push   %rbp
	struct mlx5_wqe_eth_seg *eseg = priv;

	/* HW/FW is doing parsing, so offsets are largely ignored. */
	eseg->cs_flags |= MLX5_ETH_WQE_L3_CSUM | MLX5_ETH_WQE_L4_CSUM;
      4a:	80 4a 04 c0          	orb    $0xc0,0x4(%rdx)
{
      4e:	48 89 e5             	mov    %rsp,%rbp
}
      51:	5d                   	pop    %rbp
      52:	e9 00 00 00 00       	jmp    57 <mlx5e_xsk_request_checksum+0x17>
      57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
      5e:	00 00 
      60:	90                   	nop
      61:	90                   	nop
      62:	90                   	nop
      63:	90                   	nop
      64:	90                   	nop
      65:	90                   	nop
      66:	90                   	nop
      67:	90                   	nop
      68:	90                   	nop
      69:	90                   	nop
      6a:	90                   	nop
      6b:	90                   	nop
      6c:	90                   	nop
      6d:	90                   	nop
      6e:	90                   	nop
      6f:	90                   	nop

0000000000000070 <mlx5e_xdp_rx_vlan_tag>:
{
      70:	f3 0f 1e fa          	endbr64 
      74:	e8 00 00 00 00       	call   79 <mlx5e_xdp_rx_vlan_tag+0x9>
      79:	55                   	push   %rbp
	const struct mlx5_cqe64 *cqe = _ctx->cqe;
      7a:	48 8b 47 38          	mov    0x38(%rdi),%rax
{
      7e:	48 89 e5             	mov    %rsp,%rbp
	if (!cqe_has_vlan(cqe))
      81:	f6 40 1d 01          	testb  $0x1,0x1d(%rax)
      85:	74 1b                	je     a2 <mlx5e_xdp_rx_vlan_tag+0x32>
	*vlan_proto = htons(ETH_P_8021Q);
      87:	b9 81 00 00 00       	mov    $0x81,%ecx
}
      8c:	5d                   	pop    %rbp
	*vlan_proto = htons(ETH_P_8021Q);
      8d:	66 89 0e             	mov    %cx,(%rsi)
	*vlan_tci = be16_to_cpu(cqe->vlan_info);
      90:	0f b7 40 1e          	movzwl 0x1e(%rax),%eax
      94:	66 c1 c0 08          	rol    $0x8,%ax
      98:	66 89 02             	mov    %ax,(%rdx)
	return 0;
      9b:	31 c0                	xor    %eax,%eax
}
      9d:	e9 00 00 00 00       	jmp    a2 <mlx5e_xdp_rx_vlan_tag+0x32>
		return -ENODATA;
      a2:	b8 c3 ff ff ff       	mov    $0xffffffc3,%eax
}
      a7:	5d                   	pop    %rbp
      a8:	e9 00 00 00 00       	jmp    ad <mlx5e_xdp_rx_vlan_tag+0x3d>
      ad:	0f 1f 00             	nopl   (%rax)
      b0:	90                   	nop
      b1:	90                   	nop
      b2:	90                   	nop
      b3:	90                   	nop
      b4:	90                   	nop
      b5:	90                   	nop
      b6:	90                   	nop
      b7:	90                   	nop
      b8:	90                   	nop
      b9:	90                   	nop
      ba:	90                   	nop
      bb:	90                   	nop
      bc:	90                   	nop
      bd:	90                   	nop
      be:	90                   	nop
      bf:	90                   	nop

00000000000000c0 <mlx5e_xdp_rx_hash>:
{
      c0:	f3 0f 1e fa          	endbr64 
      c4:	e8 00 00 00 00       	call   c9 <mlx5e_xdp_rx_hash+0x9>
	if (unlikely(!(_ctx->xdp.rxq->dev->features & NETIF_F_RXHASH)))
      c9:	48 8b 47 20          	mov    0x20(%rdi),%rax
{
      cd:	55                   	push   %rbp
      ce:	48 89 d1             	mov    %rdx,%rcx
	const struct mlx5_cqe64 *cqe = _ctx->cqe;
      d1:	48 8b 57 38          	mov    0x38(%rdi),%rdx
	if (unlikely(!(_ctx->xdp.rxq->dev->features & NETIF_F_RXHASH)))
      d5:	48 8b 00             	mov    (%rax),%rax
{
      d8:	48 89 e5             	mov    %rsp,%rbp
	if (unlikely(!(_ctx->xdp.rxq->dev->features & NETIF_F_RXHASH)))
      db:	f6 80 b4 00 00 00 80 	testb  $0x80,0xb4(%rax)
      e2:	74 2b                	je     10f <mlx5e_xdp_rx_hash+0x4f>
	*hash = be32_to_cpu(cqe->rss_hash_result);
      e4:	8b 42 0c             	mov    0xc(%rdx),%eax
}
      e7:	5d                   	pop    %rbp
	*hash = be32_to_cpu(cqe->rss_hash_result);
      e8:	0f c8                	bswap  %eax
      ea:	89 06                	mov    %eax,(%rsi)
	hash_type = cqe->rss_hash_type;
      ec:	0f b6 52 10          	movzbl 0x10(%rdx),%edx
	l4_type = FIELD_GET(CQE_RSS_HTYPE_L4, hash_type);
      f0:	89 d0                	mov    %edx,%eax
	ip_type = hash_type & CQE_RSS_HTYPE_IP;
      f2:	83 e2 0c             	and    $0xc,%edx
	l4_type = FIELD_GET(CQE_RSS_HTYPE_L4, hash_type);
      f5:	25 c0 00 00 00       	and    $0xc0,%eax
      fa:	c1 e8 06             	shr    $0x6,%eax
	lookup = ip_type | l4_type;
      fd:	09 d0                	or     %edx,%eax
	*rss_type = mlx5_xdp_rss_type[lookup];
      ff:	8b 04 85 00 00 00 00 	mov    0x0(,%rax,4),%eax
     106:	89 01                	mov    %eax,(%rcx)
	return 0;
     108:	31 c0                	xor    %eax,%eax
}
     10a:	e9 00 00 00 00       	jmp    10f <mlx5e_xdp_rx_hash+0x4f>
		return -ENODATA;
     10f:	b8 c3 ff ff ff       	mov    $0xffffffc3,%eax
}
     114:	5d                   	pop    %rbp
     115:	e9 00 00 00 00       	jmp    11a <mlx5e_xdp_rx_hash+0x5a>
     11a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
     120:	90                   	nop
     121:	90                   	nop
     122:	90                   	nop
     123:	90                   	nop
     124:	90                   	nop
     125:	90                   	nop
     126:	90                   	nop
     127:	90                   	nop
     128:	90                   	nop
     129:	90                   	nop
     12a:	90                   	nop
     12b:	90                   	nop
     12c:	90                   	nop
     12d:	90                   	nop
     12e:	90                   	nop
     12f:	90                   	nop

0000000000000130 <mlx5_timecounter_cyc2time>:
{
     130:	f3 0f 1e fa          	endbr64 
     134:	55                   	push   %rbp
     135:	48 89 e5             	mov    %rsp,%rbp
     138:	41 56                	push   %r14
		nsec = timecounter_cyc2time(&timer->tc, timestamp);
     13a:	4c 8d b7 90 01 00 00 	lea    0x190(%rdi),%r14
{
     141:	41 55                	push   %r13
     143:	49 89 f5             	mov    %rsi,%r13
     146:	41 54                	push   %r12
     148:	49 89 fc             	mov    %rdi,%r12
     14b:	53                   	push   %rbx
     14c:	eb 02                	jmp    150 <mlx5_timecounter_cyc2time+0x20>
#ifndef __ASSEMBLY__

/* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
static __always_inline void rep_nop(void)
{
	asm volatile("rep; nop" ::: "memory");
     14e:	f3 90                	pause  
}

#define __SEQ_RT	IS_ENABLED(CONFIG_PREEMPT_RT)

SEQCOUNT_LOCKNAME(raw_spinlock, raw_spinlock_t,  false,    raw_spin)
SEQCOUNT_LOCKNAME(spinlock,     spinlock_t,      __SEQ_RT, spin)
     150:	41 8b 5c 24 20       	mov    0x20(%r12),%ebx
 *
 * Return: count, to be passed to read_seqretry()
 */
static inline unsigned read_seqbegin(const seqlock_t *sl)
{
	unsigned ret = read_seqcount_begin(&sl->seqcount);
     155:	f6 c3 01             	test   $0x1,%bl
     158:	75 f4                	jne    14e <mlx5_timecounter_cyc2time+0x1e>
		nsec = timecounter_cyc2time(&timer->tc, timestamp);
     15a:	4c 89 ee             	mov    %r13,%rsi
     15d:	4c 89 f7             	mov    %r14,%rdi
     160:	e8 00 00 00 00       	call   165 <mlx5_timecounter_cyc2time+0x35>
	return unlikely(READ_ONCE(s->sequence) != start);
     165:	41 8b 54 24 20       	mov    0x20(%r12),%edx
	} while (read_seqretry(&clock->lock, seq));
     16a:	39 da                	cmp    %ebx,%edx
     16c:	75 e2                	jne    150 <mlx5_timecounter_cyc2time+0x20>
}
     16e:	5b                   	pop    %rbx
     16f:	41 5c                	pop    %r12
     171:	41 5d                	pop    %r13
     173:	41 5e                	pop    %r14
     175:	5d                   	pop    %rbp
     176:	e9 00 00 00 00       	jmp    17b <mlx5_timecounter_cyc2time+0x4b>
     17b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     180:	90                   	nop
     181:	90                   	nop
     182:	90                   	nop
     183:	90                   	nop
     184:	90                   	nop
     185:	90                   	nop
     186:	90                   	nop
     187:	90                   	nop
     188:	90                   	nop
     189:	90                   	nop
     18a:	90                   	nop
     18b:	90                   	nop
     18c:	90                   	nop
     18d:	90                   	nop
     18e:	90                   	nop
     18f:	90                   	nop

0000000000000190 <mlx5e_xsk_fill_timestamp>:
{
     190:	f3 0f 1e fa          	endbr64 
     194:	e8 00 00 00 00       	call   199 <mlx5e_xsk_fill_timestamp+0x9>
     199:	55                   	push   %rbp
     19a:	48 89 e5             	mov    %rsp,%rbp
     19d:	41 56                	push   %r14
     19f:	41 55                	push   %r13
     1a1:	41 54                	push   %r12
     1a3:	53                   	push   %rbx
	ts = get_cqe_ts(priv->cqe);
     1a4:	48 8b 07             	mov    (%rdi),%rax

static inline u64 get_cqe_ts(struct mlx5_cqe64 *cqe)
{
	u32 hi, lo;

	hi = be32_to_cpu(cqe->timestamp_h);
     1a7:	8b 58 30             	mov    0x30(%rax),%ebx
	lo = be32_to_cpu(cqe->timestamp_l);
     1aa:	8b 40 34             	mov    0x34(%rax),%eax
	hi = be32_to_cpu(cqe->timestamp_h);
     1ad:	0f cb                	bswap  %ebx
	lo = be32_to_cpu(cqe->timestamp_l);
     1af:	0f c8                	bswap  %eax

	return (u64)lo | ((u64)hi << 32);
     1b1:	48 c1 e3 20          	shl    $0x20,%rbx
     1b5:	89 c0                	mov    %eax,%eax
     1b7:	48 09 c3             	or     %rax,%rbx
	if (mlx5_is_real_time_rq(priv->cq->mdev) || mlx5_is_real_time_sq(priv->cq->mdev))
     1ba:	48 8b 47 08          	mov    0x8(%rdi),%rax
     1be:	4c 8b a8 08 01 00 00 	mov    0x108(%rax),%r13
	u8 rq_ts_format_cap = MLX5_CAP_GEN(mdev, rq_ts_format);
     1c5:	49 8b 85 48 03 00 00 	mov    0x348(%r13),%rax
     1cc:	8b 90 88 00 00 00    	mov    0x88(%rax),%edx
     1d2:	89 d0                	mov    %edx,%eax
     1d4:	c0 e8 04             	shr    $0x4,%al
     1d7:	83 e0 03             	and    $0x3,%eax
	return (rq_ts_format_cap == MLX5_TIMESTAMP_FORMAT_CAP_REAL_TIME ||
     1da:	83 e8 01             	sub    $0x1,%eax
     1dd:	3c 01                	cmp    $0x1,%al
     1df:	76 12                	jbe    1f3 <mlx5e_xsk_fill_timestamp+0x63>
	return (sq_ts_format_cap == MLX5_TIMESTAMP_FORMAT_CAP_REAL_TIME ||
     1e1:	c0 ea 06             	shr    $0x6,%dl
		nsec = timecounter_cyc2time(&timer->tc, timestamp);
     1e4:	4d 8d b5 e0 0f 00 00 	lea    0xfe0(%r13),%r14
	return (sq_ts_format_cap == MLX5_TIMESTAMP_FORMAT_CAP_REAL_TIME ||
     1eb:	83 ea 01             	sub    $0x1,%edx
     1ee:	80 fa 01             	cmp    $0x1,%dl
     1f1:	77 22                	ja     215 <mlx5e_xsk_fill_timestamp+0x85>
	u64 time = REAL_TIME_TO_NS(timestamp >> 32, timestamp & 0xFFFFFFFF);
     1f3:	48 89 d8             	mov    %rbx,%rax
     1f6:	89 db                	mov    %ebx,%ebx
     1f8:	48 c1 e8 20          	shr    $0x20,%rax
     1fc:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
     203:	48 01 d8             	add    %rbx,%rax
}
     206:	5b                   	pop    %rbx
     207:	41 5c                	pop    %r12
     209:	41 5d                	pop    %r13
     20b:	41 5e                	pop    %r14
     20d:	5d                   	pop    %rbp
     20e:	e9 00 00 00 00       	jmp    213 <mlx5e_xsk_fill_timestamp+0x83>
     213:	f3 90                	pause  
SEQCOUNT_LOCKNAME(spinlock,     spinlock_t,      __SEQ_RT, spin)
     215:	45 8b a5 70 0e 00 00 	mov    0xe70(%r13),%r12d
	unsigned ret = read_seqcount_begin(&sl->seqcount);
     21c:	41 f6 c4 01          	test   $0x1,%r12b
     220:	75 f1                	jne    213 <mlx5e_xsk_fill_timestamp+0x83>
		nsec = timecounter_cyc2time(&timer->tc, timestamp);
     222:	48 89 de             	mov    %rbx,%rsi
     225:	4c 89 f7             	mov    %r14,%rdi
     228:	e8 00 00 00 00       	call   22d <mlx5e_xsk_fill_timestamp+0x9d>
	return unlikely(READ_ONCE(s->sequence) != start);
     22d:	41 8b 95 70 0e 00 00 	mov    0xe70(%r13),%edx
	} while (read_seqretry(&clock->lock, seq));
     234:	44 39 e2             	cmp    %r12d,%edx
     237:	75 dc                	jne    215 <mlx5e_xsk_fill_timestamp+0x85>
     239:	5b                   	pop    %rbx
     23a:	41 5c                	pop    %r12
     23c:	41 5d                	pop    %r13
     23e:	41 5e                	pop    %r14
     240:	5d                   	pop    %rbp
     241:	e9 00 00 00 00       	jmp    246 <mlx5e_xsk_fill_timestamp+0xb6>
     246:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
     24d:	00 00 00 
     250:	90                   	nop
     251:	90                   	nop
     252:	90                   	nop
     253:	90                   	nop
     254:	90                   	nop
     255:	90                   	nop
     256:	90                   	nop
     257:	90                   	nop
     258:	90                   	nop
     259:	90                   	nop
     25a:	90                   	nop
     25b:	90                   	nop
     25c:	90                   	nop
     25d:	90                   	nop
     25e:	90                   	nop
     25f:	90                   	nop

0000000000000260 <mlx5e_free_xdpsq_desc>:
				  struct mlx5e_xdp_wqe_info *wi,
				  u32 *xsk_frames,
				  struct xdp_frame_bulk *bq,
				  struct mlx5e_cq *cq,
				  struct mlx5_cqe64 *cqe)
{
     260:	e8 00 00 00 00       	call   265 <mlx5e_free_xdpsq_desc+0x5>
     265:	55                   	push   %rbp
     266:	48 89 e5             	mov    %rsp,%rbp
     269:	41 57                	push   %r15
     26b:	41 56                	push   %r14
     26d:	41 55                	push   %r13
     26f:	41 54                	push   %r12
     271:	53                   	push   %rbx
     272:	48 83 ec 50          	sub    $0x50,%rsp
     276:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
     27a:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     281:	00 00 
     283:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     287:	31 c0                	xor    %eax,%eax
	struct mlx5e_xdp_info_fifo *xdpi_fifo = &sq->db.xdpi_fifo;
	u16 i;

	for (i = 0; i < wi->num_pkts; i++) {
     289:	80 7e 01 00          	cmpb   $0x0,0x1(%rsi)
     28d:	0f 84 a5 00 00 00    	je     338 <mlx5e_free_xdpsq_desc+0xd8>
     293:	45 31 e4             	xor    %r12d,%r12d
}
#define arch_atomic64_add_negative arch_atomic64_add_negative

static __always_inline s64 arch_atomic64_add_return(s64 i, atomic64_t *v)
{
	return i + xadd(&v->counter, i);
     296:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
     29a:	49 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%r14
     2a1:	44 89 e3             	mov    %r12d,%ebx
     2a4:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
     2a8:	49 89 fc             	mov    %rdi,%r12
     2ab:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
     2af:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
     2b3:	eb 1a                	jmp    2cf <mlx5e_free_xdpsq_desc+0x6f>
		union mlx5e_xdp_info xdpi = mlx5e_xdpi_fifo_pop(xdpi_fifo);

		switch (xdpi.mode) {
     2b5:	85 c0                	test   %eax,%eax
     2b7:	0f 84 32 01 00 00    	je     3ef <mlx5e_free_xdpsq_desc+0x18f>

			(*xsk_frames)++;
			break;
		}
		default:
			WARN_ON_ONCE(true);
     2bd:	0f 0b                	ud2    
	for (i = 0; i < wi->num_pkts; i++) {
     2bf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
     2c3:	83 c3 01             	add    $0x1,%ebx
     2c6:	0f b6 40 01          	movzbl 0x1(%rax),%eax
     2ca:	66 39 c3             	cmp    %ax,%bx
     2cd:	73 69                	jae    338 <mlx5e_free_xdpsq_desc+0xd8>
}

static inline union mlx5e_xdp_info
mlx5e_xdpi_fifo_pop(struct mlx5e_xdp_info_fifo *fifo)
{
	return fifo->xi[(*fifo->cc)++ & fifo->mask];
     2cf:	49 8b 94 24 58 02 00 	mov    0x258(%r12),%rdx
     2d6:	00 
     2d7:	49 8b 8c 24 50 02 00 	mov    0x250(%r12),%rcx
     2de:	00 
     2df:	8b 02                	mov    (%rdx),%eax
     2e1:	8d 70 01             	lea    0x1(%rax),%esi
     2e4:	89 32                	mov    %esi,(%rdx)
     2e6:	41 23 84 24 68 02 00 	and    0x268(%r12),%eax
     2ed:	00 
     2ee:	48 8b 04 c1          	mov    (%rcx,%rax,8),%rax
		switch (xdpi.mode) {
     2f2:	83 f8 01             	cmp    $0x1,%eax
     2f5:	74 67                	je     35e <mlx5e_free_xdpsq_desc+0xfe>
     2f7:	83 f8 02             	cmp    $0x2,%eax
     2fa:	75 b9                	jne    2b5 <mlx5e_free_xdpsq_desc+0x55>
			struct mlx5e_xsk_tx_complete priv = {
     2fc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
     300:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
     304:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
     308:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	return xskb->orig_addr + (offset << XSK_UNALIGNED_BUF_OFFSET_SHIFT);
}

static inline bool xp_tx_metadata_enabled(const struct xsk_buff_pool *pool)
{
	return pool->tx_metadata_len > 0;
     30c:	49 8b 84 24 00 02 00 	mov    0x200(%r12),%rax
     313:	00 
			if (xp_tx_metadata_enabled(sq->xsk_pool)) {
     314:	80 b8 d4 00 00 00 00 	cmpb   $0x0,0xd4(%rax)
     31b:	0f 85 69 01 00 00    	jne    48a <mlx5e_free_xdpsq_desc+0x22a>
			(*xsk_frames)++;
     321:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
	for (i = 0; i < wi->num_pkts; i++) {
     325:	83 c3 01             	add    $0x1,%ebx
			(*xsk_frames)++;
     328:	83 00 01             	addl   $0x1,(%rax)
	for (i = 0; i < wi->num_pkts; i++) {
     32b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
     32f:	0f b6 40 01          	movzbl 0x1(%rax),%eax
     333:	66 39 c3             	cmp    %ax,%bx
     336:	72 97                	jb     2cf <mlx5e_free_xdpsq_desc+0x6f>
		}
	}
}
     338:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
     33c:	65 48 2b 04 25 28 00 	sub    %gs:0x28,%rax
     343:	00 00 
     345:	0f 85 17 02 00 00    	jne    562 <mlx5e_free_xdpsq_desc+0x302>
     34b:	48 83 c4 50          	add    $0x50,%rsp
     34f:	5b                   	pop    %rbx
     350:	41 5c                	pop    %r12
     352:	41 5d                	pop    %r13
     354:	41 5e                	pop    %r14
     356:	41 5f                	pop    %r15
     358:	5d                   	pop    %rbp
     359:	e9 00 00 00 00       	jmp    35e <mlx5e_free_xdpsq_desc+0xfe>
     35e:	49 8b 94 24 58 02 00 	mov    0x258(%r12),%rdx
     365:	00 
     366:	49 8b 8c 24 50 02 00 	mov    0x250(%r12),%rcx
     36d:	00 
			u8 num, n = 0;
     36e:	45 31 ff             	xor    %r15d,%r15d
     371:	8b 02                	mov    (%rdx),%eax
     373:	8d 70 01             	lea    0x1(%rax),%esi
     376:	89 32                	mov    %esi,(%rdx)
     378:	41 23 84 24 68 02 00 	and    0x268(%r12),%eax
     37f:	00 
			num = xdpi.page.num;
     380:	44 0f b6 2c c1       	movzbl (%rcx,%rax,8),%r13d
     385:	eb 26                	jmp    3ad <mlx5e_free_xdpsq_desc+0x14d>
     387:	4c 89 f0             	mov    %r14,%rax
     38a:	f0 48 0f c1 46 28    	lock xadd %rax,0x28(%rsi)

		return 0;
	}

	ret = atomic_long_sub_return(nr, &page->pp_ref_count);
	WARN_ON(ret < 0);
     390:	48 83 e8 01          	sub    $0x1,%rax
     394:	0f 88 cd 00 00 00    	js     467 <mlx5e_free_xdpsq_desc+0x207>
	/* We are the last user here too, reset pp_ref_count back to 1 to
	 * ensure all pages have been partitioned into 1 piece initially,
	 * this should be the rare case when the last two fragment users call
	 * page_pool_unref_page() currently.
	 */
	if (unlikely(!ret))
     39a:	0f 84 ce 00 00 00    	je     46e <mlx5e_free_xdpsq_desc+0x20e>
			} while (++n < num);
     3a0:	41 83 c7 01          	add    $0x1,%r15d
     3a4:	45 38 ef             	cmp    %r13b,%r15b
     3a7:	0f 83 12 ff ff ff    	jae    2bf <mlx5e_free_xdpsq_desc+0x5f>
     3ad:	49 8b 94 24 58 02 00 	mov    0x258(%r12),%rdx
     3b4:	00 
     3b5:	49 8b 8c 24 50 02 00 	mov    0x250(%r12),%rcx
     3bc:	00 
     3bd:	8b 02                	mov    (%rdx),%eax
     3bf:	8d 70 01             	lea    0x1(%rax),%esi
     3c2:	89 32                	mov    %esi,(%rdx)
     3c4:	41 23 84 24 68 02 00 	and    0x268(%r12),%eax
     3cb:	00 
     3cc:	48 8b 34 c1          	mov    (%rcx,%rax,8),%rsi
	return __READ_ONCE((v)->counter);
     3d0:	48 8b 46 28          	mov    0x28(%rsi),%rax
				page_pool_recycle_direct(page->pp, page);
     3d4:	48 8b 7e 10          	mov    0x10(%rsi),%rdi
	if (atomic_long_read(&page->pp_ref_count) == nr) {
     3d8:	48 83 f8 01          	cmp    $0x1,%rax
     3dc:	75 a9                	jne    387 <mlx5e_free_xdpsq_desc+0x127>
	 */
#ifdef CONFIG_PAGE_POOL
	if (!page_pool_is_last_ref(page))
		return;

	page_pool_put_unrefed_page(pool, page, dma_sync_size, allow_direct);
     3de:	b9 01 00 00 00       	mov    $0x1,%ecx
     3e3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
     3e8:	e8 00 00 00 00       	call   3ed <mlx5e_free_xdpsq_desc+0x18d>
     3ed:	eb b1                	jmp    3a0 <mlx5e_free_xdpsq_desc+0x140>
     3ef:	49 8b 94 24 58 02 00 	mov    0x258(%r12),%rdx
     3f6:	00 
     3f7:	49 8b 8c 24 50 02 00 	mov    0x250(%r12),%rcx
     3fe:	00 
}

static inline void dma_unmap_single_attrs(struct device *dev, dma_addr_t addr,
		size_t size, enum dma_data_direction dir, unsigned long attrs)
{
	return dma_unmap_page_attrs(dev, addr, size, dir, attrs);
     3ff:	45 31 c0             	xor    %r8d,%r8d
     402:	8b 02                	mov    (%rdx),%eax
     404:	8d 70 01             	lea    0x1(%rax),%esi
     407:	89 32                	mov    %esi,(%rdx)
     409:	49 8b 94 24 58 02 00 	mov    0x258(%r12),%rdx
     410:	00 
     411:	41 23 84 24 68 02 00 	and    0x268(%r12),%eax
     418:	00 
     419:	4c 8b 3c c1          	mov    (%rcx,%rax,8),%r15
     41d:	8b 02                	mov    (%rdx),%eax
     41f:	49 8b 8c 24 50 02 00 	mov    0x250(%r12),%rcx
     426:	00 
     427:	8d 70 01             	lea    0x1(%rax),%esi
     42a:	89 32                	mov    %esi,(%rdx)
     42c:	41 23 84 24 68 02 00 	and    0x268(%r12),%eax
     433:	00 
     434:	48 8b 34 c1          	mov    (%rcx,%rax,8),%rsi
			dma_unmap_single(sq->pdev, dma_addr,
     438:	41 0f b7 57 08       	movzwl 0x8(%r15),%edx
     43d:	b9 01 00 00 00       	mov    $0x1,%ecx
     442:	49 8b bc 24 80 02 00 	mov    0x280(%r12),%rdi
     449:	00 
     44a:	e8 00 00 00 00       	call   44f <mlx5e_free_xdpsq_desc+0x1ef>
			if (xdp_frame_has_frags(xdpf)) {
     44f:	41 f6 47 24 01       	testb  $0x1,0x24(%r15)
     454:	75 69                	jne    4bf <mlx5e_free_xdpsq_desc+0x25f>
			xdp_return_frame_bulk(xdpf, bq);
     456:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
     45a:	4c 89 ff             	mov    %r15,%rdi
     45d:	e8 00 00 00 00       	call   462 <mlx5e_free_xdpsq_desc+0x202>
			break;
     462:	e9 58 fe ff ff       	jmp    2bf <mlx5e_free_xdpsq_desc+0x5f>
	WARN_ON(ret < 0);
     467:	0f 0b                	ud2    
	if (unlikely(!ret))
     469:	e9 32 ff ff ff       	jmp    3a0 <mlx5e_free_xdpsq_desc+0x140>
	__WRITE_ONCE(v->counter, i);
     46e:	48 c7 46 28 01 00 00 	movq   $0x1,0x28(%rsi)
     475:	00 
	page_pool_put_unrefed_page(pool, page, dma_sync_size, allow_direct);
     476:	b9 01 00 00 00       	mov    $0x1,%ecx
     47b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
     480:	e8 00 00 00 00       	call   485 <mlx5e_free_xdpsq_desc+0x225>
     485:	e9 16 ff ff ff       	jmp    3a0 <mlx5e_free_xdpsq_desc+0x140>
     48a:	49 8b 94 24 58 02 00 	mov    0x258(%r12),%rdx
     491:	00 
     492:	49 8b 8c 24 50 02 00 	mov    0x250(%r12),%rcx
     499:	00 
					    void *priv)
{
	if (!compl)
		return;

	*compl->tx_timestamp = ops->tmo_fill_timestamp(priv);
     49a:	48 8d 7d c0          	lea    -0x40(%rbp),%rdi
     49e:	8b 02                	mov    (%rdx),%eax
     4a0:	8d 70 01             	lea    0x1(%rax),%esi
     4a3:	89 32                	mov    %esi,(%rdx)
     4a5:	41 23 84 24 68 02 00 	and    0x268(%r12),%eax
     4ac:	00 
     4ad:	4c 8b 2c c1          	mov    (%rcx,%rax,8),%r13
     4b1:	e8 da fc ff ff       	call   190 <mlx5e_xsk_fill_timestamp>
     4b6:	49 89 45 00          	mov    %rax,0x0(%r13)
     4ba:	e9 62 fe ff ff       	jmp    321 <mlx5e_free_xdpsq_desc+0xc1>
static inline struct skb_shared_info *
xdp_get_shared_info_from_frame(struct xdp_frame *frame)
{
	void *data_hard_start = frame->data - frame->headroom - sizeof(*frame);

	return (struct skb_shared_info *)(data_hard_start + frame->frame_sz -
     4bf:	41 8b 47 20          	mov    0x20(%r15),%eax
	void *data_hard_start = frame->data - frame->headroom - sizeof(*frame);
     4c3:	41 0f b7 57 0a       	movzwl 0xa(%r15),%edx
	return (struct skb_shared_info *)(data_hard_start + frame->frame_sz -
     4c8:	48 2d 68 01 00 00    	sub    $0x168,%rax
     4ce:	48 29 d0             	sub    %rdx,%rax
     4d1:	49 03 07             	add    (%r15),%rax
				for (j = 0; j < sinfo->nr_frags; j++) {
     4d4:	80 78 02 00          	cmpb   $0x0,0x2(%rax)
     4d8:	0f 84 78 ff ff ff    	je     456 <mlx5e_free_xdpsq_desc+0x1f6>
     4de:	66 89 5d 96          	mov    %bx,-0x6a(%rbp)
     4e2:	45 31 ed             	xor    %r13d,%r13d
     4e5:	48 89 c3             	mov    %rax,%rbx
					skb_frag_t *frag = &sinfo->frags[j];
     4e8:	49 63 d5             	movslq %r13d,%rdx
     4eb:	48 83 fa 11          	cmp    $0x11,%rdx
     4ef:	77 58                	ja     549 <mlx5e_free_xdpsq_desc+0x2e9>
     4f1:	49 8b b4 24 58 02 00 	mov    0x258(%r12),%rsi
     4f8:	00 
     4f9:	49 8b bc 24 50 02 00 	mov    0x250(%r12),%rdi
     500:	00 
 * skb_frag_size() - Returns the size of a skb fragment
 * @frag: skb fragment
 */
static inline unsigned int skb_frag_size(const skb_frag_t *frag)
{
	return frag->bv_len;
     501:	48 c1 e2 04          	shl    $0x4,%rdx
				for (j = 0; j < sinfo->nr_frags; j++) {
     505:	41 83 c5 01          	add    $0x1,%r13d
     509:	8b 0e                	mov    (%rsi),%ecx
     50b:	44 8d 41 01          	lea    0x1(%rcx),%r8d
     50f:	44 89 06             	mov    %r8d,(%rsi)
     512:	41 23 8c 24 68 02 00 	and    0x268(%r12),%ecx
     519:	00 
     51a:	45 31 c0             	xor    %r8d,%r8d
     51d:	48 8b 34 cf          	mov    (%rdi,%rcx,8),%rsi
					dma_unmap_single(sq->pdev, dma_addr,
     521:	8b 54 1a 38          	mov    0x38(%rdx,%rbx,1),%edx
     525:	b9 01 00 00 00       	mov    $0x1,%ecx
     52a:	49 8b bc 24 80 02 00 	mov    0x280(%r12),%rdi
     531:	00 
     532:	e8 00 00 00 00       	call   537 <mlx5e_free_xdpsq_desc+0x2d7>
				for (j = 0; j < sinfo->nr_frags; j++) {
     537:	0f b6 53 02          	movzbl 0x2(%rbx),%edx
     53b:	44 39 ea             	cmp    %r13d,%edx
     53e:	7f a8                	jg     4e8 <mlx5e_free_xdpsq_desc+0x288>
     540:	0f b7 5d 96          	movzwl -0x6a(%rbp),%ebx
     544:	e9 0d ff ff ff       	jmp    456 <mlx5e_free_xdpsq_desc+0x1f6>
					skb_frag_t *frag = &sinfo->frags[j];
     549:	48 89 d6             	mov    %rdx,%rsi
     54c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     553:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
     557:	e8 00 00 00 00       	call   55c <mlx5e_free_xdpsq_desc+0x2fc>
     55c:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
     560:	eb 8f                	jmp    4f1 <mlx5e_free_xdpsq_desc+0x291>
}
     562:	e8 00 00 00 00       	call   567 <mlx5e_free_xdpsq_desc+0x307>
     567:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
     56e:	00 00 
     570:	90                   	nop
     571:	90                   	nop
     572:	90                   	nop
     573:	90                   	nop
     574:	90                   	nop
     575:	90                   	nop
     576:	90                   	nop
     577:	90                   	nop
     578:	90                   	nop
     579:	90                   	nop
     57a:	90                   	nop
     57b:	90                   	nop
     57c:	90                   	nop
     57d:	90                   	nop
     57e:	90                   	nop
     57f:	90                   	nop

0000000000000580 <mlx5e_xmit_xdp_frame_check>:
{
     580:	f3 0f 1e fa          	endbr64 
     584:	e8 00 00 00 00       	call   589 <mlx5e_xmit_xdp_frame_check+0x9>
	if (unlikely(!mlx5e_wqc_has_room_for(&sq->wq, sq->cc, sq->pc, stop_room))) {
     589:	0f b7 4f 04          	movzwl 0x4(%rdi),%ecx
     58d:	0f b7 57 44          	movzwl 0x44(%rdi),%edx
{
     591:	55                   	push   %rbp
}

static inline bool
mlx5e_wqc_has_room_for(struct mlx5_wq_cyc *wq, u16 cc, u16 pc, u16 n)
{
	return (mlx5_wq_cyc_ctr2ix(wq, cc - pc) >= n) || (cc == pc);
     592:	89 c8                	mov    %ecx,%eax
     594:	29 d0                	sub    %edx,%eax
	*wq->db = cpu_to_be32(wq->wqe_ctr);
}

static inline u16 mlx5_wq_cyc_ctr2ix(struct mlx5_wq_cyc *wq, u16 ctr)
{
	return ctr & wq->fbc.sz_m1;
     596:	66 23 87 10 02 00 00 	and    0x210(%rdi),%ax
     59d:	48 89 e5             	mov    %rsp,%rbp
     5a0:	75 05                	jne    5a7 <mlx5e_xmit_xdp_frame_check+0x27>
     5a2:	66 39 ca             	cmp    %cx,%dx
     5a5:	75 0b                	jne    5b2 <mlx5e_xmit_xdp_frame_check+0x32>
	return MLX5E_XDP_CHECK_OK;
     5a7:	b8 01 00 00 00       	mov    $0x1,%eax
}
     5ac:	5d                   	pop    %rbp
     5ad:	e9 00 00 00 00       	jmp    5b2 <mlx5e_xmit_xdp_frame_check+0x32>
	if (sq->doorbell_cseg) {
     5b2:	48 8b 47 48          	mov    0x48(%rdi),%rax
     5b6:	48 85 c0             	test   %rax,%rax
     5b9:	74 27                	je     5e2 <mlx5e_xmit_xdp_frame_check+0x62>
		mlx5e_notify_hw(&sq->wq, sq->pc, sq->uar_map, sq->doorbell_cseg);
     5bb:	48 8b 8f 70 02 00 00 	mov    0x270(%rdi),%rcx

static inline void
mlx5e_notify_hw(struct mlx5_wq_cyc *wq, u16 pc, void __iomem *uar_map,
		struct mlx5_wqe_ctrl_seg *ctrl)
{
	ctrl->fm_ce_se |= MLX5_WQE_CTRL_CQ_UPDATE;
     5c2:	80 48 0b 08          	orb    $0x8,0xb(%rax)
	/* ensure wqe is visible to device before updating doorbell record */
	dma_wmb();

	*wq->db = cpu_to_be32(pc);
     5c6:	48 8b b7 20 02 00 00 	mov    0x220(%rdi),%rsi
     5cd:	0f ca                	bswap  %edx
     5cf:	89 16                	mov    %edx,(%rsi)

	/* ensure doorbell record is visible to device before ringing the
	 * doorbell
	 */
	wmb();
     5d1:	0f ae f8             	sfence 
 */

static inline void mlx5_write64(__be32 val[2], void __iomem *dest)
{
#if BITS_PER_LONG == 64
	__raw_writeq(*(u64 *)val, dest);
     5d4:	48 8b 00             	mov    (%rax),%rax
#ifdef CONFIG_X86_64

build_mmio_read(readq, "q", u64, "=r", :"memory")
build_mmio_read(__readq, "q", u64, "=r", )
build_mmio_write(writeq, "q", u64, "r", :"memory")
build_mmio_write(__writeq, "q", u64, "r", )
     5d7:	48 89 01             	mov    %rax,(%rcx)
		sq->doorbell_cseg = NULL;
     5da:	48 c7 47 48 00 00 00 	movq   $0x0,0x48(%rdi)
     5e1:	00 
			sq->stats->full++;
     5e2:	48 8b 87 30 02 00 00 	mov    0x230(%rdi),%rax
     5e9:	48 83 40 20 01       	addq   $0x1,0x20(%rax)
     5ee:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
     5f3:	5d                   	pop    %rbp
     5f4:	e9 00 00 00 00       	jmp    5f9 <mlx5e_xmit_xdp_frame_check+0x79>
     5f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
     600:	90                   	nop
     601:	90                   	nop
     602:	90                   	nop
     603:	90                   	nop
     604:	90                   	nop
     605:	90                   	nop
     606:	90                   	nop
     607:	90                   	nop
     608:	90                   	nop
     609:	90                   	nop
     60a:	90                   	nop
     60b:	90                   	nop
     60c:	90                   	nop
     60d:	90                   	nop
     60e:	90                   	nop
     60f:	90                   	nop

0000000000000610 <mlx5e_xdp_rx_timestamp>:
{
     610:	f3 0f 1e fa          	endbr64 
     614:	e8 00 00 00 00       	call   619 <mlx5e_xdp_rx_timestamp+0x9>
	if (unlikely(!mlx5e_rx_hw_stamp(_ctx->rq->tstamp)))
     619:	48 8b 57 40          	mov    0x40(%rdi),%rdx
	return config->rx_filter == HWTSTAMP_FILTER_ALL;
     61d:	48 8b 82 80 03 00 00 	mov    0x380(%rdx),%rax
     624:	83 78 08 01          	cmpl   $0x1,0x8(%rax)
     628:	75 5e                	jne    688 <mlx5e_xdp_rx_timestamp+0x78>
{
     62a:	55                   	push   %rbp
     62b:	48 89 e5             	mov    %rsp,%rbp
     62e:	41 57                	push   %r15
     630:	41 56                	push   %r14
     632:	41 55                	push   %r13
     634:	41 54                	push   %r12
     636:	49 89 f4             	mov    %rsi,%r12
     639:	53                   	push   %rbx
					 _ctx->rq->clock, get_cqe_ts(_ctx->cqe));
     63a:	48 8b 47 38          	mov    0x38(%rdi),%rax
	hi = be32_to_cpu(cqe->timestamp_h);
     63e:	8b 58 30             	mov    0x30(%rax),%ebx
	lo = be32_to_cpu(cqe->timestamp_l);
     641:	8b 40 34             	mov    0x34(%rax),%eax
	hi = be32_to_cpu(cqe->timestamp_h);
     644:	0f cb                	bswap  %ebx
	lo = be32_to_cpu(cqe->timestamp_l);
     646:	0f c8                	bswap  %eax
	return (u64)lo | ((u64)hi << 32);
     648:	48 c1 e3 20          	shl    $0x20,%rbx
     64c:	89 c0                	mov    %eax,%eax
     64e:	48 09 c3             	or     %rax,%rbx
	*timestamp =  mlx5e_cqe_ts_to_ns(_ctx->rq->ptp_cyc2time,
     651:	48 8b 82 40 05 00 00 	mov    0x540(%rdx),%rax
	return INDIRECT_CALL_2(func, mlx5_real_time_cyc2time, mlx5_timecounter_cyc2time,
     658:	48 3d 00 00 00 00    	cmp    $0x0,%rax
     65e:	75 32                	jne    692 <mlx5e_xdp_rx_timestamp+0x82>
	u64 time = REAL_TIME_TO_NS(timestamp >> 32, timestamp & 0xFFFFFFFF);
     660:	48 89 d8             	mov    %rbx,%rax
     663:	89 db                	mov    %ebx,%ebx
     665:	48 c1 e8 20          	shr    $0x20,%rax
     669:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
     670:	48 01 d8             	add    %rbx,%rax
     673:	49 89 04 24          	mov    %rax,(%r12)
	return 0;
     677:	31 c0                	xor    %eax,%eax
}
     679:	5b                   	pop    %rbx
     67a:	41 5c                	pop    %r12
     67c:	41 5d                	pop    %r13
     67e:	41 5e                	pop    %r14
     680:	41 5f                	pop    %r15
     682:	5d                   	pop    %rbp
     683:	e9 00 00 00 00       	jmp    688 <mlx5e_xdp_rx_timestamp+0x78>
		return -ENODATA;
     688:	b8 c3 ff ff ff       	mov    $0xffffffc3,%eax
}
     68d:	e9 00 00 00 00       	jmp    692 <mlx5e_xdp_rx_timestamp+0x82>
	*timestamp =  mlx5e_cqe_ts_to_ns(_ctx->rq->ptp_cyc2time,
     692:	4c 8b ba 88 03 00 00 	mov    0x388(%rdx),%r15
     699:	48 3d 00 00 00 00    	cmp    $0x0,%rax
     69f:	75 2b                	jne    6cc <mlx5e_xdp_rx_timestamp+0xbc>
		nsec = timecounter_cyc2time(&timer->tc, timestamp);
     6a1:	4d 8d af 90 01 00 00 	lea    0x190(%r15),%r13
SEQCOUNT_LOCKNAME(spinlock,     spinlock_t,      __SEQ_RT, spin)
     6a8:	eb 02                	jmp    6ac <mlx5e_xdp_rx_timestamp+0x9c>
     6aa:	f3 90                	pause  
     6ac:	45 8b 77 20          	mov    0x20(%r15),%r14d
	unsigned ret = read_seqcount_begin(&sl->seqcount);
     6b0:	41 f6 c6 01          	test   $0x1,%r14b
     6b4:	75 f4                	jne    6aa <mlx5e_xdp_rx_timestamp+0x9a>
     6b6:	48 89 de             	mov    %rbx,%rsi
     6b9:	4c 89 ef             	mov    %r13,%rdi
     6bc:	e8 00 00 00 00       	call   6c1 <mlx5e_xdp_rx_timestamp+0xb1>
	return unlikely(READ_ONCE(s->sequence) != start);
     6c1:	41 8b 57 20          	mov    0x20(%r15),%edx
	} while (read_seqretry(&clock->lock, seq));
     6c5:	41 39 d6             	cmp    %edx,%r14d
     6c8:	74 a9                	je     673 <mlx5e_xdp_rx_timestamp+0x63>
     6ca:	eb e0                	jmp    6ac <mlx5e_xdp_rx_timestamp+0x9c>
     6cc:	48 89 de             	mov    %rbx,%rsi
     6cf:	4c 89 ff             	mov    %r15,%rdi
     6d2:	e8 00 00 00 00       	call   6d7 <mlx5e_xdp_rx_timestamp+0xc7>
     6d7:	eb 9a                	jmp    673 <mlx5e_xdp_rx_timestamp+0x63>
     6d9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
     6e0:	90                   	nop
     6e1:	90                   	nop
     6e2:	90                   	nop
     6e3:	90                   	nop
     6e4:	90                   	nop
     6e5:	90                   	nop
     6e6:	90                   	nop
     6e7:	90                   	nop
     6e8:	90                   	nop
     6e9:	90                   	nop
     6ea:	90                   	nop
     6eb:	90                   	nop
     6ec:	90                   	nop
     6ed:	90                   	nop
     6ee:	90                   	nop
     6ef:	90                   	nop

00000000000006f0 <mlx5e_xdpsq_get_next_pi>:
{
     6f0:	e8 00 00 00 00       	call   6f5 <mlx5e_xdpsq_get_next_pi+0x5>
     6f5:	55                   	push   %rbp
     6f6:	48 89 e5             	mov    %rsp,%rbp
     6f9:	41 57                	push   %r15
     6fb:	41 56                	push   %r14
     6fd:	41 55                	push   %r13
     6ff:	41 54                	push   %r12
     701:	53                   	push   %rbx
     702:	48 89 fb             	mov    %rdi,%rbx
     705:	89 f7                	mov    %esi,%edi
     707:	48 83 ec 18          	sub    $0x18,%rsp
     70b:	8b 8b 10 02 00 00    	mov    0x210(%rbx),%ecx
     711:	0f b7 43 44          	movzwl 0x44(%rbx),%eax
}

static inline u32
mlx5_frag_buf_get_idx_last_contig_stride(struct mlx5_frag_buf_ctrl *fbc, u32 ix)
{
	u32 last_frag_stride_idx = (ix + fbc->strides_offset) | fbc->frag_sz_m1;
     715:	0f b7 b3 16 02 00 00 	movzwl 0x216(%rbx),%esi
     71c:	44 0f b7 83 14 02 00 	movzwl 0x214(%rbx),%r8d
     723:	00 
     724:	21 c8                	and    %ecx,%eax
	return mlx5_frag_buf_get_wqe(&wq->fbc, ix);
}

static inline u16 mlx5_wq_cyc_get_contig_wqebbs(struct mlx5_wq_cyc *wq, u16 ix)
{
	return mlx5_frag_buf_get_idx_last_contig_stride(&wq->fbc, ix) - ix + 1;
     726:	0f b7 d0             	movzwl %ax,%edx
     729:	01 f2                	add    %esi,%edx
     72b:	44 09 c2             	or     %r8d,%edx

	return min_t(u32, last_frag_stride_idx - fbc->strides_offset, fbc->sz_m1);
     72e:	29 f2                	sub    %esi,%edx
     730:	39 ca                	cmp    %ecx,%edx
     732:	0f 47 d1             	cmova  %ecx,%edx
     735:	29 c2                	sub    %eax,%edx
     737:	83 c2 01             	add    $0x1,%edx
	if (unlikely(contig_wqebbs < size)) {
     73a:	66 39 fa             	cmp    %di,%dx
     73d:	72 13                	jb     752 <mlx5e_xdpsq_get_next_pi+0x62>
}
     73f:	48 83 c4 18          	add    $0x18,%rsp
     743:	5b                   	pop    %rbx
     744:	41 5c                	pop    %r12
     746:	41 5d                	pop    %r13
     748:	41 5e                	pop    %r14
     74a:	41 5f                	pop    %r15
     74c:	5d                   	pop    %rbp
     74d:	e9 00 00 00 00       	jmp    752 <mlx5e_xdpsq_get_next_pi+0x62>
		wi = &sq->db.wqe_info[pi];
     752:	48 8b 8b 48 02 00 00 	mov    0x248(%rbx),%rcx
     759:	0f b7 c0             	movzwl %ax,%eax
		edge_wi = wi + contig_wqebbs;
     75c:	44 0f b7 e2          	movzwl %dx,%r12d
		wi = &sq->db.wqe_info[pi];
     760:	4c 8d 3c 41          	lea    (%rcx,%rax,2),%r15
		edge_wi = wi + contig_wqebbs;
     764:	4f 8d 04 67          	lea    (%r15,%r12,2),%r8
		for (; wi < edge_wi; wi++) {
     768:	4d 39 c7             	cmp    %r8,%r15
     76b:	0f 83 a8 00 00 00    	jae    819 <mlx5e_xdpsq_get_next_pi+0x129>
     771:	44 0f b7 0d 00 00 00 	movzwl 0x0(%rip),%r9d        # 779 <mlx5e_xdpsq_get_next_pi+0x89>
     778:	00 
			*wi = (struct mlx5e_xdp_wqe_info) {
     779:	66 45 89 0f          	mov    %r9w,(%r15)
	return ctr & wq->fbc.sz_m1;
     77d:	44 8b ab 10 02 00 00 	mov    0x210(%rbx),%r13d
	ix  += fbc->strides_offset;
     784:	0f b7 83 16 02 00 00 	movzwl 0x216(%rbx),%eax
     78b:	66 44 23 6b 44       	and    0x44(%rbx),%r13w
	frag = ix >> fbc->log_frag_strides;
     790:	0f b6 8b 1a 02 00 00 	movzbl 0x21a(%rbx),%ecx
	return mlx5_frag_buf_get_wqe(&wq->fbc, ix);
     797:	45 0f b7 ed          	movzwl %r13w,%r13d
			mlx5e_post_nop(wq, sq->sqn, &sq->pc);
     79b:	44 8b b3 78 02 00 00 	mov    0x278(%rbx),%r14d
	ix  += fbc->strides_offset;
     7a2:	41 01 c5             	add    %eax,%r13d
	frag = ix >> fbc->log_frag_strides;
     7a5:	80 f9 1f             	cmp    $0x1f,%cl
     7a8:	0f 87 00 00 00 00    	ja     7ae <mlx5e_xdpsq_get_next_pi+0xbe>
     7ae:	45 89 ea             	mov    %r13d,%r10d
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
     7b1:	0f b7 83 14 02 00 00 	movzwl 0x214(%rbx),%eax
	frag = ix >> fbc->log_frag_strides;
     7b8:	41 d3 ea             	shr    %cl,%r10d
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
     7bb:	0f b6 8b 19 02 00 00 	movzbl 0x219(%rbx),%ecx
     7c2:	44 21 e8             	and    %r13d,%eax
     7c5:	80 f9 1f             	cmp    $0x1f,%cl
     7c8:	0f 87 00 00 00 00    	ja     7ce <mlx5e_xdpsq_get_next_pi+0xde>
     7ce:	49 c1 e2 04          	shl    $0x4,%r10
     7d2:	4c 03 93 08 02 00 00 	add    0x208(%rbx),%r10
     7d9:	d3 e0                	shl    %cl,%eax
		for (; wi < edge_wi; wi++) {
     7db:	49 83 c7 02          	add    $0x2,%r15
     7df:	49 03 02             	add    (%r10),%rax
	cseg->qpn_ds           = cpu_to_be32((sqn << 8) | 0x01);
     7e2:	41 c1 e6 08          	shl    $0x8,%r14d
	memset(cseg, 0, sizeof(*cseg));
     7e6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	cseg->qpn_ds           = cpu_to_be32((sqn << 8) | 0x01);
     7ed:	41 83 ce 01          	or     $0x1,%r14d
	memset(cseg, 0, sizeof(*cseg));
     7f1:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
     7f8:	00 
	cseg->opmod_idx_opcode = cpu_to_be32((*pc << 8) | MLX5_OPCODE_NOP);
     7f9:	0f b7 53 44          	movzwl 0x44(%rbx),%edx
	cseg->qpn_ds           = cpu_to_be32((sqn << 8) | 0x01);
     7fd:	41 0f ce             	bswap  %r14d
     800:	44 89 70 04          	mov    %r14d,0x4(%rax)
	cseg->opmod_idx_opcode = cpu_to_be32((*pc << 8) | MLX5_OPCODE_NOP);
     804:	c1 e2 08             	shl    $0x8,%edx
     807:	0f ca                	bswap  %edx
     809:	89 10                	mov    %edx,(%rax)
	(*pc)++;
     80b:	66 83 43 44 01       	addw   $0x1,0x44(%rbx)
     810:	4d 39 c7             	cmp    %r8,%r15
     813:	0f 82 60 ff ff ff    	jb     779 <mlx5e_xdpsq_get_next_pi+0x89>
		sq->stats->nops += contig_wqebbs;
     819:	48 8b 83 30 02 00 00 	mov    0x230(%rbx),%rax
     820:	4c 01 60 18          	add    %r12,0x18(%rax)
	return ctr & wq->fbc.sz_m1;
     824:	8b 83 10 02 00 00    	mov    0x210(%rbx),%eax
     82a:	66 23 43 44          	and    0x44(%rbx),%ax
	return pi;
     82e:	e9 0c ff ff ff       	jmp    73f <mlx5e_xdpsq_get_next_pi+0x4f>
     833:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
     83a:	00 00 00 00 
     83e:	66 90                	xchg   %ax,%ax
     840:	90                   	nop
     841:	90                   	nop
     842:	90                   	nop
     843:	90                   	nop
     844:	90                   	nop
     845:	90                   	nop
     846:	90                   	nop
     847:	90                   	nop
     848:	90                   	nop
     849:	90                   	nop
     84a:	90                   	nop
     84b:	90                   	nop
     84c:	90                   	nop
     84d:	90                   	nop
     84e:	90                   	nop
     84f:	90                   	nop

0000000000000850 <mlx5e_xmit_xdp_frame_check_mpwqe>:
{
     850:	f3 0f 1e fa          	endbr64 
     854:	e8 00 00 00 00       	call   859 <mlx5e_xmit_xdp_frame_check_mpwqe+0x9>
     859:	55                   	push   %rbp
	if (unlikely(!sq->mpwqe.wqe)) {
     85a:	48 83 7f 50 00       	cmpq   $0x0,0x50(%rdi)
	return MLX5E_XDP_CHECK_OK;
     85f:	b8 01 00 00 00       	mov    $0x1,%eax
{
     864:	48 89 e5             	mov    %rsp,%rbp
	if (unlikely(!sq->mpwqe.wqe)) {
     867:	74 06                	je     86f <mlx5e_xmit_xdp_frame_check_mpwqe+0x1f>
}
     869:	5d                   	pop    %rbp
     86a:	e9 00 00 00 00       	jmp    86f <mlx5e_xmit_xdp_frame_check_mpwqe+0x1f>
		if (unlikely(!mlx5e_wqc_has_room_for(&sq->wq, sq->cc, sq->pc,
     86f:	0f b7 4f 04          	movzwl 0x4(%rdi),%ecx
     873:	0f b7 57 44          	movzwl 0x44(%rdi),%edx
	return (mlx5_wq_cyc_ctr2ix(wq, cc - pc) >= n) || (cc == pc);
     877:	89 c8                	mov    %ecx,%eax
     879:	29 d0                	sub    %edx,%eax
     87b:	66 23 87 10 02 00 00 	and    0x210(%rdi),%ax
     882:	66 3b 87 8c 02 00 00 	cmp    0x28c(%rdi),%ax
     889:	73 05                	jae    890 <mlx5e_xmit_xdp_frame_check_mpwqe+0x40>
     88b:	66 39 ca             	cmp    %cx,%dx
     88e:	75 0b                	jne    89b <mlx5e_xmit_xdp_frame_check_mpwqe+0x4b>
		return MLX5E_XDP_CHECK_START_MPWQE;
     890:	b8 02 00 00 00       	mov    $0x2,%eax
}
     895:	5d                   	pop    %rbp
     896:	e9 00 00 00 00       	jmp    89b <mlx5e_xmit_xdp_frame_check_mpwqe+0x4b>
	if (sq->doorbell_cseg) {
     89b:	48 8b 47 48          	mov    0x48(%rdi),%rax
     89f:	48 85 c0             	test   %rax,%rax
     8a2:	74 27                	je     8cb <mlx5e_xmit_xdp_frame_check_mpwqe+0x7b>
		mlx5e_notify_hw(&sq->wq, sq->pc, sq->uar_map, sq->doorbell_cseg);
     8a4:	48 8b 8f 70 02 00 00 	mov    0x270(%rdi),%rcx
	ctrl->fm_ce_se |= MLX5_WQE_CTRL_CQ_UPDATE;
     8ab:	80 48 0b 08          	orb    $0x8,0xb(%rax)
	*wq->db = cpu_to_be32(pc);
     8af:	48 8b b7 20 02 00 00 	mov    0x220(%rdi),%rsi
     8b6:	0f ca                	bswap  %edx
     8b8:	89 16                	mov    %edx,(%rsi)
	wmb();
     8ba:	0f ae f8             	sfence 
     8bd:	48 8b 00             	mov    (%rax),%rax
     8c0:	48 89 01             	mov    %rax,(%rcx)
		sq->doorbell_cseg = NULL;
     8c3:	48 c7 47 48 00 00 00 	movq   $0x0,0x48(%rdi)
     8ca:	00 
			sq->stats->full++;
     8cb:	48 8b 87 30 02 00 00 	mov    0x230(%rdi),%rax
     8d2:	48 83 40 20 01       	addq   $0x1,0x20(%rax)
     8d7:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
}
     8dc:	5d                   	pop    %rbp
     8dd:	e9 00 00 00 00       	jmp    8e2 <mlx5e_xmit_xdp_frame_check_mpwqe+0x92>
     8e2:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
     8e9:	00 00 00 00 
     8ed:	0f 1f 00             	nopl   (%rax)
     8f0:	90                   	nop
     8f1:	90                   	nop
     8f2:	90                   	nop
     8f3:	90                   	nop
     8f4:	90                   	nop
     8f5:	90                   	nop
     8f6:	90                   	nop
     8f7:	90                   	nop
     8f8:	90                   	nop
     8f9:	90                   	nop
     8fa:	90                   	nop
     8fb:	90                   	nop
     8fc:	90                   	nop
     8fd:	90                   	nop
     8fe:	90                   	nop
     8ff:	90                   	nop

0000000000000900 <mlx5e_xmit_xdp_frame>:
{
     900:	f3 0f 1e fa          	endbr64 
     904:	e8 00 00 00 00       	call   909 <mlx5e_xmit_xdp_frame+0x9>
     909:	55                   	push   %rbp
     90a:	48 89 e5             	mov    %rsp,%rbp
     90d:	41 57                	push   %r15
     90f:	41 56                	push   %r14
     911:	41 89 d6             	mov    %edx,%r14d
     914:	41 55                	push   %r13
     916:	41 54                	push   %r12
     918:	49 89 f4             	mov    %rsi,%r12
     91b:	53                   	push   %rbx
     91c:	48 83 ec 38          	sub    $0x38,%rsp
	dma_addr_t dma_addr = xdptxd->dma_addr;
     920:	48 8b 06             	mov    (%rsi),%rax
	u32 dma_len = xdptxd->len;
     923:	44 8b 7e 10          	mov    0x10(%rsi),%r15d
{
     927:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
	frags_size = xdptxd->has_frags ? xdptxdf->sinfo->xdp_frags_size : 0;
     92b:	0f b6 76 13          	movzbl 0x13(%rsi),%esi
	dma_addr_t dma_addr = xdptxd->dma_addr;
     92f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	struct mlx5e_xdpsq_stats *stats = sq->stats;
     933:	48 8b 87 30 02 00 00 	mov    0x230(%rdi),%rax
	u32 dma_len = xdptxd->len;
     93a:	41 81 e7 ff ff ff 7f 	and    $0x7fffffff,%r15d
	inline_ok = sq->min_inline_mode == MLX5_INLINE_MODE_NONE ||
     941:	41 83 ff 11          	cmp    $0x11,%r15d
	struct mlx5e_xdpsq_stats *stats = sq->stats;
     945:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	inline_ok = sq->min_inline_mode == MLX5_INLINE_MODE_NONE ||
     949:	0f b6 87 8f 02 00 00 	movzbl 0x28f(%rdi),%eax
     950:	0f 97 c1             	seta   %cl
     953:	84 c0                	test   %al,%al
     955:	0f 94 c2             	sete   %dl
     958:	08 d1                	or     %dl,%cl
     95a:	88 4d d7             	mov    %cl,-0x29(%rbp)
     95d:	0f 84 2c 03 00 00    	je     c8f <mlx5e_xmit_xdp_frame+0x38f>
     963:	48 89 fb             	mov    %rdi,%rbx
	frags_size = xdptxd->has_frags ? xdptxdf->sinfo->xdp_frags_size : 0;
     966:	44 89 fa             	mov    %r15d,%edx
     969:	40 84 f6             	test   %sil,%sil
     96c:	0f 88 44 02 00 00    	js     bb6 <mlx5e_xmit_xdp_frame+0x2b6>
	if (unlikely(!inline_ok || sq->hw_mtu < dma_len + frags_size)) {
     972:	39 93 98 02 00 00    	cmp    %edx,0x298(%rbx)
     978:	0f 82 11 03 00 00    	jb     c8f <mlx5e_xmit_xdp_frame+0x38f>
	if (sq->min_inline_mode != MLX5_INLINE_MODE_NONE)
     97e:	3c 01                	cmp    $0x1,%al
     980:	89 c7                	mov    %eax,%edi
     982:	19 d2                	sbb    %edx,%edx
     984:	40 f6 df             	neg    %dil
     987:	45 19 c9             	sbb    %r9d,%r9d
     98a:	41 83 e1 12          	and    $0x12,%r9d
     98e:	f6 d8                	neg    %al
     990:	66 45 19 c0          	sbb    %r8w,%r8w
	linear = !!(dma_len - inline_hdr_sz);
     994:	31 c0                	xor    %eax,%eax
	if (sq->min_inline_mode != MLX5_INLINE_MODE_NONE)
     996:	41 83 e0 12          	and    $0x12,%r8d
	linear = !!(dma_len - inline_hdr_sz);
     99a:	45 39 cf             	cmp    %r9d,%r15d
     99d:	0f 95 c0             	setne  %al
	ds_cnt = MLX5E_TX_WQE_EMPTY_DS_COUNT + linear + !!inline_hdr_sz;
     9a0:	8d 7c 02 03          	lea    0x3(%rdx,%rax,1),%edi
     9a4:	66 89 7d d4          	mov    %di,-0x2c(%rbp)
	if (!check_result) {
     9a8:	45 85 f6             	test   %r14d,%r14d
     9ab:	74 21                	je     9ce <mlx5e_xmit_xdp_frame+0xce>
	if (unlikely(check_result < 0))
     9ad:	0f 89 82 02 00 00    	jns    c35 <mlx5e_xmit_xdp_frame+0x335>
		return false;
     9b3:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
}
     9b7:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
     9bb:	48 83 c4 38          	add    $0x38,%rsp
     9bf:	5b                   	pop    %rbx
     9c0:	41 5c                	pop    %r12
     9c2:	41 5d                	pop    %r13
     9c4:	41 5e                	pop    %r14
     9c6:	41 5f                	pop    %r15
     9c8:	5d                   	pop    %rbp
     9c9:	e9 00 00 00 00       	jmp    9ce <mlx5e_xmit_xdp_frame+0xce>
	u8 num_wqebbs = 1;
     9ce:	c6 45 d6 01          	movb   $0x1,-0x2a(%rbp)
     9d2:	b8 01 00 00 00       	mov    $0x1,%eax
		if (xdptxd->has_frags) {
     9d7:	40 84 f6             	test   %sil,%sil
     9da:	79 22                	jns    9fe <mlx5e_xmit_xdp_frame+0xfe>
			ds_cnt += xdptxdf->sinfo->nr_frags;
     9dc:	49 8b 44 24 18       	mov    0x18(%r12),%rax
     9e1:	0f b6 40 02          	movzbl 0x2(%rax),%eax
     9e5:	01 c7                	add    %eax,%edi
     9e7:	41 89 c6             	mov    %eax,%r14d
			num_wqebbs = DIV_ROUND_UP(ds_cnt, MLX5_SEND_WQEBB_NUM_DS);
     9ea:	8d 47 03             	lea    0x3(%rdi),%eax
			ds_cnt += xdptxdf->sinfo->nr_frags;
     9ed:	66 89 7d d4          	mov    %di,-0x2c(%rbp)
			num_wqebbs = DIV_ROUND_UP(ds_cnt, MLX5_SEND_WQEBB_NUM_DS);
     9f1:	0f b7 c0             	movzwl %ax,%eax
     9f4:	c1 f8 02             	sar    $0x2,%eax
     9f7:	88 45 d6             	mov    %al,-0x2a(%rbp)
	if (unlikely(!mlx5e_wqc_has_room_for(&sq->wq, sq->cc, sq->pc, stop_room))) {
     9fa:	8d 44 00 ff          	lea    -0x1(%rax,%rax,1),%eax
     9fe:	0f b7 73 04          	movzwl 0x4(%rbx),%esi
     a02:	0f b7 4b 44          	movzwl 0x44(%rbx),%ecx
	return (mlx5_wq_cyc_ctr2ix(wq, cc - pc) >= n) || (cc == pc);
     a06:	89 f2                	mov    %esi,%edx
     a08:	29 ca                	sub    %ecx,%edx
     a0a:	66 23 93 10 02 00 00 	and    0x210(%rbx),%dx
     a11:	66 39 c2             	cmp    %ax,%dx
     a14:	73 09                	jae    a1f <mlx5e_xmit_xdp_frame+0x11f>
     a16:	66 39 f1             	cmp    %si,%cx
     a19:	0f 85 27 02 00 00    	jne    c46 <mlx5e_xmit_xdp_frame+0x346>
	pi = mlx5e_xdpsq_get_next_pi(sq, num_wqebbs);
     a1f:	0f b6 75 d6          	movzbl -0x2a(%rbp),%esi
     a23:	48 89 df             	mov    %rbx,%rdi
     a26:	44 89 4d b0          	mov    %r9d,-0x50(%rbp)
     a2a:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
     a2e:	e8 bd fc ff ff       	call   6f0 <mlx5e_xdpsq_get_next_pi>
	frag = ix >> fbc->log_frag_strides;
     a33:	0f b6 8b 1a 02 00 00 	movzbl 0x21a(%rbx),%ecx
     a3a:	44 8b 45 d0          	mov    -0x30(%rbp),%r8d
	ix  += fbc->strides_offset;
     a3e:	44 0f b7 9b 16 02 00 	movzwl 0x216(%rbx),%r11d
     a45:	00 
     a46:	41 89 c2             	mov    %eax,%r10d
	return mlx5_frag_buf_get_wqe(&wq->fbc, ix);
     a49:	0f b7 c0             	movzwl %ax,%eax
	frag = ix >> fbc->log_frag_strides;
     a4c:	44 8b 4d b0          	mov    -0x50(%rbp),%r9d
	ix  += fbc->strides_offset;
     a50:	41 01 c3             	add    %eax,%r11d
	frag = ix >> fbc->log_frag_strides;
     a53:	80 f9 1f             	cmp    $0x1f,%cl
     a56:	0f 87 00 00 00 00    	ja     a5c <mlx5e_xmit_xdp_frame+0x15c>
     a5c:	44 89 d8             	mov    %r11d,%eax
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
     a5f:	44 0f b7 ab 14 02 00 	movzwl 0x214(%rbx),%r13d
     a66:	00 
	frag = ix >> fbc->log_frag_strides;
     a67:	d3 e8                	shr    %cl,%eax
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
     a69:	0f b6 8b 19 02 00 00 	movzbl 0x219(%rbx),%ecx
     a70:	45 21 dd             	and    %r11d,%r13d
     a73:	80 f9 1f             	cmp    $0x1f,%cl
     a76:	0f 87 00 00 00 00    	ja     a7c <mlx5e_xmit_xdp_frame+0x17c>
     a7c:	48 c1 e0 04          	shl    $0x4,%rax
     a80:	48 03 83 08 02 00 00 	add    0x208(%rbx),%rax
     a87:	41 d3 e5             	shl    %cl,%r13d
     a8a:	4c 03 28             	add    (%rax),%r13
 * Useful for spinlocks to avoid one state transition in the
 * cache coherency protocol:
 */
static __always_inline void prefetchw(const void *x)
{
	alternative_input(BASE_PREFETCH, "prefetchw %P1",
     a8d:	41 0f 18 4d 00       	prefetcht0 0x0(%r13)
     a92:	41 0f 18 4d 40       	prefetcht0 0x40(%r13)
	dseg = wqe->data;
     a97:	49 8d 45 20          	lea    0x20(%r13),%rax
	u32 dma_len = xdptxd->len;
     a9b:	44 89 f9             	mov    %r15d,%ecx
	if (inline_hdr_sz) {
     a9e:	66 45 85 c0          	test   %r8w,%r8w
     aa2:	74 2f                	je     ad3 <mlx5e_xmit_xdp_frame+0x1d3>
		memcpy(eseg->inline_hdr.start, xdptxd->data, sizeof(eseg->inline_hdr.start));
     aa4:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
		dma_addr += inline_hdr_sz;
     aa9:	48 83 45 c0 12       	addq   $0x12,-0x40(%rbp)
		memcpy(eseg->inline_hdr.start, xdptxd->data, sizeof(eseg->inline_hdr.start));
     aae:	0f b7 12             	movzwl (%rdx),%edx
     ab1:	66 41 89 55 1e       	mov    %dx,0x1e(%r13)
		memcpy(dseg, xdptxd->data + sizeof(eseg->inline_hdr.start),
     ab6:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
     abb:	48 8b 4a 02          	mov    0x2(%rdx),%rcx
     abf:	49 89 4d 20          	mov    %rcx,0x20(%r13)
     ac3:	48 8b 52 0a          	mov    0xa(%rdx),%rdx
		dma_len  -= inline_hdr_sz;
     ac7:	41 8d 4f ee          	lea    -0x12(%r15),%ecx
		memcpy(dseg, xdptxd->data + sizeof(eseg->inline_hdr.start),
     acb:	48 89 50 08          	mov    %rdx,0x8(%rax)
		dseg++;
     acf:	49 8d 45 30          	lea    0x30(%r13),%rax
	if (linear) {
     ad3:	45 39 cf             	cmp    %r9d,%r15d
     ad6:	74 1c                	je     af4 <mlx5e_xmit_xdp_frame+0x1f4>
		dseg->addr       = cpu_to_be64(dma_addr);
     ad8:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
		dseg->byte_count = cpu_to_be32(dma_len);
     adc:	0f c9                	bswap  %ecx
     ade:	89 08                	mov    %ecx,(%rax)
		dseg++;
     ae0:	48 83 c0 10          	add    $0x10,%rax
		dseg->addr       = cpu_to_be64(dma_addr);
     ae4:	48 0f ca             	bswap  %rdx
     ae7:	48 89 50 f8          	mov    %rdx,-0x8(%rax)
		dseg->lkey       = sq->mkey_be;
     aeb:	8b 93 88 02 00 00    	mov    0x288(%rbx),%edx
     af1:	89 50 f4             	mov    %edx,-0xc(%rax)
	cseg->opmod_idx_opcode = cpu_to_be32((sq->pc << 8) | MLX5_OPCODE_SEND);
     af4:	0f b7 53 44          	movzwl 0x44(%rbx),%edx
     af8:	c1 e2 08             	shl    $0x8,%edx
     afb:	83 ca 0a             	or     $0xa,%edx
     afe:	0f ca                	bswap  %edx
     b00:	41 89 55 00          	mov    %edx,0x0(%r13)
}

static __always_inline bool constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
     b04:	48 8b 93 90 02 00 00 	mov    0x290(%rbx),%rdx
	if (test_bit(MLX5E_SQ_STATE_XDP_MULTIBUF, &sq->state)) {
     b0b:	80 e6 01             	and    $0x1,%dh
     b0e:	0f 84 b4 00 00 00    	je     bc8 <mlx5e_xmit_xdp_frame+0x2c8>
		eseg->inline_hdr.sz = cpu_to_be16(inline_hdr_sz);
     b14:	66 41 c1 c0 08       	rol    $0x8,%r8w
		memset(&cseg->trailer, 0, sizeof(cseg->trailer));
     b19:	49 c7 45 08 00 00 00 	movq   $0x0,0x8(%r13)
     b20:	00 
		memset(eseg, 0, sizeof(*eseg) - sizeof(eseg->trailer));
     b21:	49 c7 45 10 00 00 00 	movq   $0x0,0x10(%r13)
     b28:	00 
     b29:	41 c7 45 18 00 00 00 	movl   $0x0,0x18(%r13)
     b30:	00 
		eseg->inline_hdr.sz = cpu_to_be16(inline_hdr_sz);
     b31:	66 45 89 45 1c       	mov    %r8w,0x1c(%r13)
		for (i = 0; i < num_frags; i++) {
     b36:	45 85 f6             	test   %r14d,%r14d
     b39:	0f 84 bd 00 00 00    	je     bfc <mlx5e_xmit_xdp_frame+0x2fc>
     b3f:	4d 63 f6             	movslq %r14d,%r14
     b42:	45 31 ff             	xor    %r15d,%r15d
     b45:	31 d2                	xor    %edx,%edx
     b47:	4a 8d 0c f5 00 00 00 	lea    0x0(,%r14,8),%rcx
     b4e:	00 
     b4f:	eb 32                	jmp    b83 <mlx5e_xmit_xdp_frame+0x283>
			addr = xdptxdf->dma_arr ? xdptxdf->dma_arr[i] :
     b51:	4a 8b 34 3e          	mov    (%rsi,%r15,1),%rsi
     b55:	49 c1 e6 04          	shl    $0x4,%r14
			dseg->addr = cpu_to_be64(addr);
     b59:	48 0f ce             	bswap  %rsi
     b5c:	4a 89 74 78 08       	mov    %rsi,0x8(%rax,%r15,2)
		for (i = 0; i < num_frags; i++) {
     b61:	83 c2 01             	add    $0x1,%edx
			dseg->byte_count = cpu_to_be32(skb_frag_size(frag));
     b64:	43 8b 74 06 38       	mov    0x38(%r14,%r8,1),%esi
     b69:	0f ce                	bswap  %esi
     b6b:	42 89 34 78          	mov    %esi,(%rax,%r15,2)
			dseg->lkey = sq->mkey_be;
     b6f:	8b b3 88 02 00 00    	mov    0x288(%rbx),%esi
     b75:	42 89 74 78 04       	mov    %esi,0x4(%rax,%r15,2)
		for (i = 0; i < num_frags; i++) {
     b7a:	49 83 c7 08          	add    $0x8,%r15
     b7e:	49 39 cf             	cmp    %rcx,%r15
     b81:	74 79                	je     bfc <mlx5e_xmit_xdp_frame+0x2fc>
			skb_frag_t *frag = &xdptxdf->sinfo->frags[i];
     b83:	4c 63 f2             	movslq %edx,%r14
     b86:	4d 8b 44 24 18       	mov    0x18(%r12),%r8
     b8b:	49 83 fe 11          	cmp    $0x11,%r14
     b8f:	0f 87 08 01 00 00    	ja     c9d <mlx5e_xmit_xdp_frame+0x39d>
			addr = xdptxdf->dma_arr ? xdptxdf->dma_arr[i] :
     b95:	49 8b 74 24 20       	mov    0x20(%r12),%rsi
     b9a:	48 85 f6             	test   %rsi,%rsi
     b9d:	75 b2                	jne    b51 <mlx5e_xmit_xdp_frame+0x251>
 *
 * Returns the &struct page associated with @frag.
 */
static inline struct page *skb_frag_page(const skb_frag_t *frag)
{
	return frag->bv_page;
     b9f:	4c 89 f6             	mov    %r14,%rsi
     ba2:	48 c1 e6 04          	shl    $0x4,%rsi
     ba6:	4c 01 c6             	add    %r8,%rsi
 * Fetch the DMA address of the page. The page pool to which the page belongs
 * must had been created with PP_FLAG_DMA_MAP.
 */
static inline dma_addr_t page_pool_get_dma_addr(struct page *page)
{
	dma_addr_t ret = page->dma_addr;
     ba9:	48 8b 7e 30          	mov    0x30(%rsi),%rdi
				skb_frag_off(frag);
     bad:	8b 76 3c             	mov    0x3c(%rsi),%esi
			addr = xdptxdf->dma_arr ? xdptxdf->dma_arr[i] :
     bb0:	48 03 77 20          	add    0x20(%rdi),%rsi
     bb4:	eb 9f                	jmp    b55 <mlx5e_xmit_xdp_frame+0x255>
	frags_size = xdptxd->has_frags ? xdptxdf->sinfo->xdp_frags_size : 0;
     bb6:	49 8b 54 24 18       	mov    0x18(%r12),%rdx
	if (unlikely(!inline_ok || sq->hw_mtu < dma_len + frags_size)) {
     bbb:	8b 7a 24             	mov    0x24(%rdx),%edi
     bbe:	44 01 ff             	add    %r15d,%edi
     bc1:	89 fa                	mov    %edi,%edx
     bc3:	e9 aa fd ff ff       	jmp    972 <mlx5e_xmit_xdp_frame+0x72>
		cseg->fm_ce_se = 0;
     bc8:	41 c6 45 0b 00       	movb   $0x0,0xb(%r13)
		sq->pc++;
     bcd:	0f b7 43 44          	movzwl 0x44(%rbx),%eax
     bd1:	83 c0 01             	add    $0x1,%eax
		sq->pc += num_wqebbs;
     bd4:	66 89 43 44          	mov    %ax,0x44(%rbx)
	if (!meta)
     bd8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
     bdc:	48 85 c0             	test   %rax,%rax
     bdf:	74 0a                	je     beb <mlx5e_xmit_xdp_frame+0x2eb>
		if (meta->flags & XDP_TXMD_FLAGS_CHECKSUM)
     be1:	f6 00 02             	testb  $0x2,(%rax)
     be4:	74 05                	je     beb <mlx5e_xmit_xdp_frame+0x2eb>
	eseg->cs_flags |= MLX5_ETH_WQE_L3_CSUM | MLX5_ETH_WQE_L4_CSUM;
     be6:	41 80 4d 14 c0       	orb    $0xc0,0x14(%r13)
	stats->xmit++;
     beb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	sq->doorbell_cseg = cseg;
     bef:	4c 89 6b 48          	mov    %r13,0x48(%rbx)
	stats->xmit++;
     bf3:	48 83 00 01          	addq   $0x1,(%rax)
	return true;
     bf7:	e9 bb fd ff ff       	jmp    9b7 <mlx5e_xmit_xdp_frame+0xb7>
		cseg->qpn_ds = cpu_to_be32((sq->sqn << 8) | ds_cnt);
     bfc:	8b 83 78 02 00 00    	mov    0x278(%rbx),%eax
     c02:	0f b7 55 d4          	movzwl -0x2c(%rbp),%edx
		sq->db.wqe_info[pi] = (struct mlx5e_xdp_wqe_info) {
     c06:	0f b6 7d d6          	movzbl -0x2a(%rbp),%edi
		cseg->qpn_ds = cpu_to_be32((sq->sqn << 8) | ds_cnt);
     c0a:	c1 e0 08             	shl    $0x8,%eax
     c0d:	09 d0                	or     %edx,%eax
		sq->db.wqe_info[pi] = (struct mlx5e_xdp_wqe_info) {
     c0f:	41 0f b7 d2          	movzwl %r10w,%edx
		cseg->qpn_ds = cpu_to_be32((sq->sqn << 8) | ds_cnt);
     c13:	0f c8                	bswap  %eax
     c15:	41 89 45 04          	mov    %eax,0x4(%r13)
		sq->db.wqe_info[pi] = (struct mlx5e_xdp_wqe_info) {
     c19:	48 8b 83 48 02 00 00 	mov    0x248(%rbx),%rax
     c20:	48 8d 04 50          	lea    (%rax,%rdx,2),%rax
     c24:	40 88 38             	mov    %dil,(%rax)
     c27:	c6 40 01 01          	movb   $0x1,0x1(%rax)
		sq->pc += num_wqebbs;
     c2b:	40 0f b6 c7          	movzbl %dil,%eax
     c2f:	66 03 43 44          	add    0x44(%rbx),%ax
     c33:	eb 9f                	jmp    bd4 <mlx5e_xmit_xdp_frame+0x2d4>
	u8 num_wqebbs = 1;
     c35:	c6 45 d6 01          	movb   $0x1,-0x2a(%rbp)
     c39:	be 01 00 00 00       	mov    $0x1,%esi
	int num_frags = 0;
     c3e:	45 31 f6             	xor    %r14d,%r14d
     c41:	e9 dd fd ff ff       	jmp    a23 <mlx5e_xmit_xdp_frame+0x123>
	if (sq->doorbell_cseg) {
     c46:	48 8b 43 48          	mov    0x48(%rbx),%rax
     c4a:	48 85 c0             	test   %rax,%rax
     c4d:	74 32                	je     c81 <mlx5e_xmit_xdp_frame+0x381>
		mlx5e_notify_hw(&sq->wq, sq->pc, sq->uar_map, sq->doorbell_cseg);
     c4f:	48 8b 93 70 02 00 00 	mov    0x270(%rbx),%rdx
	ctrl->fm_ce_se |= MLX5_WQE_CTRL_CQ_UPDATE;
     c56:	80 48 0b 08          	orb    $0x8,0xb(%rax)
	*wq->db = cpu_to_be32(pc);
     c5a:	48 8b b3 20 02 00 00 	mov    0x220(%rbx),%rsi
     c61:	0f c9                	bswap  %ecx
     c63:	89 0e                	mov    %ecx,(%rsi)
	wmb();
     c65:	0f ae f8             	sfence 
     c68:	48 8b 00             	mov    (%rax),%rax
     c6b:	48 89 02             	mov    %rax,(%rdx)
			sq->stats->full++;
     c6e:	48 8b 83 30 02 00 00 	mov    0x230(%rbx),%rax
		sq->doorbell_cseg = NULL;
     c75:	48 c7 43 48 00 00 00 	movq   $0x0,0x48(%rbx)
     c7c:	00 
     c7d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
     c81:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
     c85:	48 83 40 20 01       	addq   $0x1,0x20(%rax)
	if (unlikely(check_result < 0))
     c8a:	e9 24 fd ff ff       	jmp    9b3 <mlx5e_xmit_xdp_frame+0xb3>
		stats->err++;
     c8f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
     c93:	48 83 40 28 01       	addq   $0x1,0x28(%rax)
		return false;
     c98:	e9 16 fd ff ff       	jmp    9b3 <mlx5e_xmit_xdp_frame+0xb3>
			skb_frag_t *frag = &xdptxdf->sinfo->frags[i];
     c9d:	4c 89 f6             	mov    %r14,%rsi
     ca0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     ca7:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
     cab:	44 89 55 ac          	mov    %r10d,-0x54(%rbp)
     caf:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
     cb3:	89 55 d0             	mov    %edx,-0x30(%rbp)
     cb6:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
     cba:	e8 00 00 00 00       	call   cbf <mlx5e_xmit_xdp_frame+0x3bf>
     cbf:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
     cc3:	44 8b 55 ac          	mov    -0x54(%rbp),%r10d
     cc7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
     ccb:	8b 55 d0             	mov    -0x30(%rbp),%edx
     cce:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
     cd2:	e9 be fe ff ff       	jmp    b95 <mlx5e_xmit_xdp_frame+0x295>
     cd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
     cde:	00 00 
     ce0:	90                   	nop
     ce1:	90                   	nop
     ce2:	90                   	nop
     ce3:	90                   	nop
     ce4:	90                   	nop
     ce5:	90                   	nop
     ce6:	90                   	nop
     ce7:	90                   	nop
     ce8:	90                   	nop
     ce9:	90                   	nop
     cea:	90                   	nop
     ceb:	90                   	nop
     cec:	90                   	nop
     ced:	90                   	nop
     cee:	90                   	nop
     cef:	90                   	nop

0000000000000cf0 <mlx5e_xdp_max_mtu>:
{
     cf0:	f3 0f 1e fa          	endbr64 
     cf4:	e8 00 00 00 00       	call   cf9 <mlx5e_xdp_max_mtu+0x9>
     cf9:	55                   	push   %rbp
     cfa:	48 89 e5             	mov    %rsp,%rbp
     cfd:	53                   	push   %rbx
     cfe:	48 89 fb             	mov    %rdi,%rbx
	int hr = mlx5e_get_linear_rq_headroom(params, xsk);
     d01:	e8 00 00 00 00       	call   d06 <mlx5e_xdp_max_mtu+0x16>
     d06:	0f b7 d0             	movzwl %ax,%edx
	return MLX5E_HW2SW_MTU(params, SKB_MAX_HEAD(hr));
     d09:	b8 c0 0e 00 00       	mov    $0xec0,%eax
     d0e:	2b 83 54 01 00 00    	sub    0x154(%rbx),%eax
}
     d14:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
     d18:	c9                   	leave  
	return MLX5E_HW2SW_MTU(params, SKB_MAX_HEAD(hr));
     d19:	29 d0                	sub    %edx,%eax
}
     d1b:	e9 00 00 00 00       	jmp    d20 <mlx5e_xdp_max_mtu+0x30>
     d20:	90                   	nop
     d21:	90                   	nop
     d22:	90                   	nop
     d23:	90                   	nop
     d24:	90                   	nop
     d25:	90                   	nop
     d26:	90                   	nop
     d27:	90                   	nop
     d28:	90                   	nop
     d29:	90                   	nop
     d2a:	90                   	nop
     d2b:	90                   	nop
     d2c:	90                   	nop
     d2d:	90                   	nop
     d2e:	90                   	nop
     d2f:	90                   	nop

0000000000000d30 <mlx5e_xdp_mpwqe_complete>:
{
     d30:	f3 0f 1e fa          	endbr64 
     d34:	e8 00 00 00 00       	call   d39 <mlx5e_xdp_mpwqe_complete+0x9>
     d39:	55                   	push   %rbp
     d3a:	48 89 f8             	mov    %rdi,%rax
	u16 ds_count = session->ds_count;
     d3d:	0f b6 4f 5c          	movzbl 0x5c(%rdi),%ecx
	u16 pi = mlx5_wq_cyc_ctr2ix(wq, sq->pc);
     d41:	0f b7 57 44          	movzwl 0x44(%rdi),%edx
	struct mlx5_wqe_ctrl_seg *cseg = &session->wqe->ctrl;
     d45:	48 8b 77 50          	mov    0x50(%rdi),%rsi
	return ctr & wq->fbc.sz_m1;
     d49:	0f b7 bf 10 02 00 00 	movzwl 0x210(%rdi),%edi
	struct mlx5e_xdp_wqe_info *wi = &sq->db.wqe_info[pi];
     d50:	4c 8b 80 48 02 00 00 	mov    0x248(%rax),%r8
{
     d57:	48 89 e5             	mov    %rsp,%rbp
     d5a:	21 d7                	and    %edx,%edi
		cpu_to_be32((sq->pc << 8) | MLX5_OPCODE_ENHANCED_MPSW);
     d5c:	c1 e2 08             	shl    $0x8,%edx
	struct mlx5e_xdp_wqe_info *wi = &sq->db.wqe_info[pi];
     d5f:	0f b7 ff             	movzwl %di,%edi
		cpu_to_be32((sq->pc << 8) | MLX5_OPCODE_ENHANCED_MPSW);
     d62:	83 ca 29             	or     $0x29,%edx
	struct mlx5e_xdp_wqe_info *wi = &sq->db.wqe_info[pi];
     d65:	49 8d 3c 78          	lea    (%r8,%rdi,2),%rdi
		cpu_to_be32((sq->pc << 8) | MLX5_OPCODE_ENHANCED_MPSW);
     d69:	0f ca                	bswap  %edx
	cseg->opmod_idx_opcode =
     d6b:	89 16                	mov    %edx,(%rsi)
	cseg->qpn_ds = cpu_to_be32((sq->sqn << 8) | ds_count);
     d6d:	44 8b 80 78 02 00 00 	mov    0x278(%rax),%r8d
     d74:	0f b6 d1             	movzbl %cl,%edx
     d77:	41 c1 e0 08          	shl    $0x8,%r8d
     d7b:	44 89 c1             	mov    %r8d,%ecx
     d7e:	09 d1                	or     %edx,%ecx
	wi->num_wqebbs = DIV_ROUND_UP(ds_count, MLX5_SEND_WQEBB_NUM_DS);
     d80:	83 c2 03             	add    $0x3,%edx
     d83:	c1 fa 02             	sar    $0x2,%edx
	cseg->qpn_ds = cpu_to_be32((sq->sqn << 8) | ds_count);
     d86:	0f c9                	bswap  %ecx
     d88:	89 4e 04             	mov    %ecx,0x4(%rsi)
	wi->num_wqebbs = DIV_ROUND_UP(ds_count, MLX5_SEND_WQEBB_NUM_DS);
     d8b:	88 17                	mov    %dl,(%rdi)
	wi->num_pkts   = session->pkt_count;
     d8d:	0f b6 48 5d          	movzbl 0x5d(%rax),%ecx
     d91:	88 4f 01             	mov    %cl,0x1(%rdi)
}
     d94:	5d                   	pop    %rbp
	sq->pc += wi->num_wqebbs;
     d95:	66 01 50 44          	add    %dx,0x44(%rax)
	sq->doorbell_cseg = cseg;
     d99:	48 89 70 48          	mov    %rsi,0x48(%rax)
	session->wqe = NULL; /* Close session */
     d9d:	48 c7 40 50 00 00 00 	movq   $0x0,0x50(%rax)
     da4:	00 
}
     da5:	e9 00 00 00 00       	jmp    daa <mlx5e_xdp_mpwqe_complete+0x7a>
     daa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
     db0:	90                   	nop
     db1:	90                   	nop
     db2:	90                   	nop
     db3:	90                   	nop
     db4:	90                   	nop
     db5:	90                   	nop
     db6:	90                   	nop
     db7:	90                   	nop
     db8:	90                   	nop
     db9:	90                   	nop
     dba:	90                   	nop
     dbb:	90                   	nop
     dbc:	90                   	nop
     dbd:	90                   	nop
     dbe:	90                   	nop
     dbf:	90                   	nop

0000000000000dc0 <mlx5e_xmit_xdp_frame_mpwqe>:
{
     dc0:	f3 0f 1e fa          	endbr64 
     dc4:	e8 00 00 00 00       	call   dc9 <mlx5e_xmit_xdp_frame_mpwqe+0x9>
     dc9:	55                   	push   %rbp
     dca:	89 d0                	mov    %edx,%eax
     dcc:	48 89 e5             	mov    %rsp,%rbp
     dcf:	41 57                	push   %r15
     dd1:	41 56                	push   %r14
     dd3:	49 89 ce             	mov    %rcx,%r14
     dd6:	41 55                	push   %r13
     dd8:	41 54                	push   %r12
     dda:	49 89 f4             	mov    %rsi,%r12
     ddd:	53                   	push   %rbx
     dde:	48 89 fb             	mov    %rdi,%rbx
     de1:	48 83 ec 38          	sub    $0x38,%rsp
	struct mlx5e_xdpsq_stats *stats = sq->stats;
     de5:	4c 8b af 30 02 00 00 	mov    0x230(%rdi),%r13
{
     dec:	65 48 8b 14 25 28 00 	mov    %gs:0x28,%rdx
     df3:	00 00 
     df5:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
     df9:	31 d2                	xor    %edx,%edx
	if (xdptxd->has_frags) {
     dfb:	80 7e 13 00          	cmpb   $0x0,0x13(%rsi)
		if (!!xdptxd->len + xdptxdf->sinfo->nr_frags > 1) {
     dff:	8b 56 10             	mov    0x10(%rsi),%edx
	if (xdptxd->has_frags) {
     e02:	0f 88 e5 00 00 00    	js     eed <mlx5e_xmit_xdp_frame_mpwqe+0x12d>
	if (unlikely(p->len > sq->hw_mtu)) {
     e08:	81 e2 ff ff ff 7f    	and    $0x7fffffff,%edx
     e0e:	39 93 98 02 00 00    	cmp    %edx,0x298(%rbx)
     e14:	0f 82 08 03 00 00    	jb     1122 <mlx5e_xmit_xdp_frame_mpwqe+0x362>
	if (!check_result)
     e1a:	85 c0                	test   %eax,%eax
     e1c:	0f 84 ad 00 00 00    	je     ecf <mlx5e_xmit_xdp_frame_mpwqe+0x10f>
	if (unlikely(check_result < 0))
     e22:	85 c0                	test   %eax,%eax
     e24:	0f 88 fd 02 00 00    	js     1127 <mlx5e_xmit_xdp_frame_mpwqe+0x367>
	if (check_result == MLX5E_XDP_CHECK_START_MPWQE) {
     e2a:	83 f8 02             	cmp    $0x2,%eax
     e2d:	0f 84 bf 01 00 00    	je     ff2 <mlx5e_xmit_xdp_frame_mpwqe+0x232>
		(struct mlx5_wqe_data_seg *)session->wqe + session->ds_count;
     e33:	48 8b 7b 50          	mov    0x50(%rbx),%rdi
     e37:	0f b6 43 5c          	movzbl 0x5c(%rbx),%eax
	u32 dma_len = xdptxd->len;
     e3b:	41 8b 54 24 10       	mov    0x10(%r12),%edx
	session->pkt_count++;
     e40:	80 43 5d 01          	addb   $0x1,0x5d(%rbx)
		(struct mlx5_wqe_data_seg *)session->wqe + session->ds_count;
     e44:	48 c1 e0 04          	shl    $0x4,%rax
	struct mlx5_wqe_data_seg *dseg =
     e48:	48 01 c7             	add    %rax,%rdi
	u32 dma_len = xdptxd->len;
     e4b:	89 d0                	mov    %edx,%eax
     e4d:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
	session->bytes_count += dma_len;
     e52:	01 43 58             	add    %eax,0x58(%rbx)
	if (session->inline_on && dma_len <= MLX5E_XDP_INLINE_WQE_SZ_THRSD) {
     e55:	80 7b 5e 00          	cmpb   $0x0,0x5e(%rbx)
     e59:	74 0b                	je     e66 <mlx5e_xmit_xdp_frame_mpwqe+0xa6>
     e5b:	3d fc 00 00 00       	cmp    $0xfc,%eax
     e60:	0f 86 0e 01 00 00    	jbe    f74 <mlx5e_xmit_xdp_frame_mpwqe+0x1b4>
	dseg->addr       = cpu_to_be64(xdptxd->dma_addr);
     e66:	49 8b 14 24          	mov    (%r12),%rdx
	dseg->byte_count = cpu_to_be32(dma_len);
     e6a:	0f c8                	bswap  %eax
     e6c:	89 07                	mov    %eax,(%rdi)
	dseg->addr       = cpu_to_be64(xdptxd->dma_addr);
     e6e:	48 0f ca             	bswap  %rdx
     e71:	48 89 57 08          	mov    %rdx,0x8(%rdi)
	dseg->lkey       = sq->mkey_be;
     e75:	8b 83 88 02 00 00    	mov    0x288(%rbx),%eax
     e7b:	89 47 04             	mov    %eax,0x4(%rdi)
	session->ds_count++;
     e7e:	0f b6 43 5c          	movzbl 0x5c(%rbx),%eax
     e82:	83 c0 01             	add    $0x1,%eax
     e85:	88 43 5c             	mov    %al,0x5c(%rbx)
	if (unlikely(mlx5e_xdp_mpwqe_is_full(session, sq->max_sq_mpw_wqebbs)))
     e88:	0f b6 93 8e 02 00 00 	movzbl 0x28e(%rbx),%edx
		return session->ds_count + MLX5E_XDP_INLINE_WQE_MAX_DS_CNT >
     e8f:	0f b6 c0             	movzbl %al,%eax
		       max_sq_mpw_wqebbs * MLX5_SEND_WQEBB_NUM_DS;
     e92:	c1 e2 02             	shl    $0x2,%edx
	if (session->inline_on)
     e95:	80 7b 5e 00          	cmpb   $0x0,0x5e(%rbx)
     e99:	75 41                	jne    edc <mlx5e_xmit_xdp_frame_mpwqe+0x11c>
     e9b:	39 d0                	cmp    %edx,%eax
     e9d:	74 44                	je     ee3 <mlx5e_xmit_xdp_frame_mpwqe+0x123>
	stats->xmit++;
     e9f:	49 83 45 00 01       	addq   $0x1,0x0(%r13)
	return true;
     ea4:	b8 01 00 00 00       	mov    $0x1,%eax
}
     ea9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
     ead:	65 48 2b 14 25 28 00 	sub    %gs:0x28,%rdx
     eb4:	00 00 
     eb6:	0f 85 9c 02 00 00    	jne    1158 <mlx5e_xmit_xdp_frame_mpwqe+0x398>
     ebc:	48 83 c4 38          	add    $0x38,%rsp
     ec0:	5b                   	pop    %rbx
     ec1:	41 5c                	pop    %r12
     ec3:	41 5d                	pop    %r13
     ec5:	41 5e                	pop    %r14
     ec7:	41 5f                	pop    %r15
     ec9:	5d                   	pop    %rbp
     eca:	e9 00 00 00 00       	jmp    ecf <mlx5e_xmit_xdp_frame_mpwqe+0x10f>
		check_result = mlx5e_xmit_xdp_frame_check_mpwqe(sq);
     ecf:	48 89 df             	mov    %rbx,%rdi
     ed2:	e8 00 00 00 00       	call   ed7 <mlx5e_xmit_xdp_frame_mpwqe+0x117>
     ed7:	e9 46 ff ff ff       	jmp    e22 <mlx5e_xmit_xdp_frame_mpwqe+0x62>
		return session->ds_count + MLX5E_XDP_INLINE_WQE_MAX_DS_CNT >
     edc:	83 c0 10             	add    $0x10,%eax
	if (unlikely(mlx5e_xdp_mpwqe_is_full(session, sq->max_sq_mpw_wqebbs)))
     edf:	39 d0                	cmp    %edx,%eax
     ee1:	7e bc                	jle    e9f <mlx5e_xmit_xdp_frame_mpwqe+0xdf>
		mlx5e_xdp_mpwqe_complete(sq);
     ee3:	48 89 df             	mov    %rbx,%rdi
     ee6:	e8 00 00 00 00       	call   eeb <mlx5e_xmit_xdp_frame_mpwqe+0x12b>
     eeb:	eb b2                	jmp    e9f <mlx5e_xmit_xdp_frame_mpwqe+0xdf>
		if (!!xdptxd->len + xdptxdf->sinfo->nr_frags > 1) {
     eed:	48 8b 76 18          	mov    0x18(%rsi),%rsi
     ef1:	41 89 d0             	mov    %edx,%r8d
     ef4:	31 c9                	xor    %ecx,%ecx
     ef6:	41 81 e0 ff ff ff 7f 	and    $0x7fffffff,%r8d
     efd:	0f b6 7e 02          	movzbl 0x2(%rsi),%edi
     f01:	0f 95 c1             	setne  %cl
     f04:	01 f9                	add    %edi,%ecx
     f06:	83 f9 01             	cmp    $0x1,%ecx
     f09:	0f 8f c3 00 00 00    	jg     fd2 <mlx5e_xmit_xdp_frame_mpwqe+0x212>
		if (!xdptxd->len) {
     f0f:	45 85 c0             	test   %r8d,%r8d
     f12:	0f 85 f0 fe ff ff    	jne    e08 <mlx5e_xmit_xdp_frame_mpwqe+0x48>
     f18:	48 8b 7e 30          	mov    0x30(%rsi),%rdi
 * Returns the address of the data within @frag. The page must already
 * be mapped.
 */
static inline void *skb_frag_address(const skb_frag_t *frag)
{
	return page_address(skb_frag_page(frag)) + skb_frag_off(frag);
     f1c:	8b 4e 3c             	mov    0x3c(%rsi),%ecx
 */
#include <linux/vmstat.h>

static __always_inline void *lowmem_page_address(const struct page *page)
{
	return page_to_virt(page);
     f1f:	48 89 fa             	mov    %rdi,%rdx
     f22:	48 2b 15 00 00 00 00 	sub    0x0(%rip),%rdx        # f29 <mlx5e_xmit_xdp_frame_mpwqe+0x169>
     f29:	48 c1 fa 06          	sar    $0x6,%rdx
     f2d:	48 c1 e2 0c          	shl    $0xc,%rdx
     f31:	48 03 15 00 00 00 00 	add    0x0(%rip),%rdx        # f38 <mlx5e_xmit_xdp_frame_mpwqe+0x178>
     f38:	48 01 ca             	add    %rcx,%rdx
     f3b:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
			tmp.len = skb_frag_size(frag);
     f3f:	8b 56 38             	mov    0x38(%rsi),%edx
     f42:	8b 75 c8             	mov    -0x38(%rbp),%esi
     f45:	81 e2 ff ff ff 7f    	and    $0x7fffffff,%edx
     f4b:	81 e6 00 00 00 80    	and    $0x80000000,%esi
     f51:	09 d6                	or     %edx,%esi
     f53:	89 75 c8             	mov    %esi,-0x38(%rbp)
			tmp.dma_addr = xdptxdf->dma_arr ? xdptxdf->dma_arr[0] :
     f56:	49 8b 74 24 20       	mov    0x20(%r12),%rsi
     f5b:	48 85 f6             	test   %rsi,%rsi
     f5e:	0f 84 ca 01 00 00    	je     112e <mlx5e_xmit_xdp_frame_mpwqe+0x36e>
     f64:	48 8b 0e             	mov    (%rsi),%rcx
     f67:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
			p = &tmp;
     f6b:	4c 8d 65 b8          	lea    -0x48(%rbp),%r12
     f6f:	e9 9a fe ff ff       	jmp    e0e <mlx5e_xmit_xdp_frame_mpwqe+0x4e>
		inline_dseg->byte_count = cpu_to_be32(dma_len | MLX5_INLINE_SEG);
     f74:	89 c1                	mov    %eax,%ecx
     f76:	81 c9 00 00 00 80    	or     $0x80000000,%ecx
     f7c:	0f c9                	bswap  %ecx
     f7e:	89 0f                	mov    %ecx,(%rdi)
		memcpy(inline_dseg->data, xdptxd->data, dma_len);
     f80:	48 8d 4f 04          	lea    0x4(%rdi),%rcx
     f84:	49 8b 74 24 08       	mov    0x8(%r12),%rsi
     f89:	83 f8 08             	cmp    $0x8,%eax
     f8c:	0f 83 62 01 00 00    	jae    10f4 <mlx5e_xmit_xdp_frame_mpwqe+0x334>
     f92:	f6 c2 04             	test   $0x4,%dl
     f95:	0f 85 a9 01 00 00    	jne    1144 <mlx5e_xmit_xdp_frame_mpwqe+0x384>
     f9b:	85 c0                	test   %eax,%eax
     f9d:	74 19                	je     fb8 <mlx5e_xmit_xdp_frame_mpwqe+0x1f8>
     f9f:	44 0f b6 06          	movzbl (%rsi),%r8d
     fa3:	83 e2 02             	and    $0x2,%edx
     fa6:	44 88 47 04          	mov    %r8b,0x4(%rdi)
     faa:	74 0c                	je     fb8 <mlx5e_xmit_xdp_frame_mpwqe+0x1f8>
     fac:	89 c2                	mov    %eax,%edx
     fae:	0f b7 74 16 fe       	movzwl -0x2(%rsi,%rdx,1),%esi
     fb3:	66 89 74 11 fe       	mov    %si,-0x2(%rcx,%rdx,1)
		u16 ds_cnt = DIV_ROUND_UP(ds_len, MLX5_SEND_WQE_DS);
     fb8:	83 c0 13             	add    $0x13,%eax
     fbb:	0f b7 c0             	movzwl %ax,%eax
     fbe:	c1 f8 04             	sar    $0x4,%eax
		session->ds_count += ds_cnt;
     fc1:	00 43 5c             	add    %al,0x5c(%rbx)
		stats->inlnw++;
     fc4:	49 83 45 10 01       	addq   $0x1,0x10(%r13)
		return session->ds_count + MLX5E_XDP_INLINE_WQE_MAX_DS_CNT >
     fc9:	0f b6 43 5c          	movzbl 0x5c(%rbx),%eax
		return;
     fcd:	e9 b6 fe ff ff       	jmp    e88 <mlx5e_xmit_xdp_frame_mpwqe+0xc8>
			if (unlikely(sq->mpwqe.wqe))
     fd2:	48 83 7b 50 00       	cmpq   $0x0,0x50(%rbx)
     fd7:	0f 85 5a 01 00 00    	jne    1137 <mlx5e_xmit_xdp_frame_mpwqe+0x377>
			return mlx5e_xmit_xdp_frame(sq, xdptxd, 0, meta);
     fdd:	4c 89 f1             	mov    %r14,%rcx
     fe0:	31 d2                	xor    %edx,%edx
     fe2:	4c 89 e6             	mov    %r12,%rsi
     fe5:	48 89 df             	mov    %rbx,%rdi
     fe8:	e8 00 00 00 00       	call   fed <mlx5e_xmit_xdp_frame_mpwqe+0x22d>
     fed:	e9 b7 fe ff ff       	jmp    ea9 <mlx5e_xmit_xdp_frame_mpwqe+0xe9>
	struct mlx5e_xdpsq_stats *stats = sq->stats;
     ff2:	4c 8b 83 30 02 00 00 	mov    0x230(%rbx),%r8
	pi = mlx5e_xdpsq_get_next_pi(sq, sq->max_sq_mpw_wqebbs);
     ff9:	0f b6 b3 8e 02 00 00 	movzbl 0x28e(%rbx),%esi
    1000:	48 89 df             	mov    %rbx,%rdi
	struct mlx5e_xdpsq_stats *stats = sq->stats;
    1003:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
	pi = mlx5e_xdpsq_get_next_pi(sq, sq->max_sq_mpw_wqebbs);
    1007:	e8 e4 f6 ff ff       	call   6f0 <mlx5e_xdpsq_get_next_pi>
	frag = ix >> fbc->log_frag_strides;
    100c:	0f b6 8b 1a 02 00 00 	movzbl 0x21a(%rbx),%ecx
    1013:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
	ix  += fbc->strides_offset;
    1017:	44 0f b7 8b 16 02 00 	movzwl 0x216(%rbx),%r9d
    101e:	00 
	return mlx5_frag_buf_get_wqe(&wq->fbc, ix);
    101f:	0f b7 c0             	movzwl %ax,%eax
    1022:	41 01 c1             	add    %eax,%r9d
	frag = ix >> fbc->log_frag_strides;
    1025:	80 f9 1f             	cmp    $0x1f,%cl
    1028:	0f 87 00 00 00 00    	ja     102e <mlx5e_xmit_xdp_frame_mpwqe+0x26e>
    102e:	45 89 cf             	mov    %r9d,%r15d
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
    1031:	0f b7 83 14 02 00 00 	movzwl 0x214(%rbx),%eax
	frag = ix >> fbc->log_frag_strides;
    1038:	41 d3 ef             	shr    %cl,%r15d
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
    103b:	0f b6 8b 19 02 00 00 	movzbl 0x219(%rbx),%ecx
    1042:	44 21 c8             	and    %r9d,%eax
    1045:	80 f9 1f             	cmp    $0x1f,%cl
    1048:	0f 87 00 00 00 00    	ja     104e <mlx5e_xmit_xdp_frame_mpwqe+0x28e>
    104e:	49 c1 e7 04          	shl    $0x4,%r15
    1052:	4c 03 bb 08 02 00 00 	add    0x208(%rbx),%r15
    1059:	d3 e0                	shl    %cl,%eax
    105b:	49 03 07             	add    (%r15),%rax
	memset(wqe, 0, wqe_size);
    105e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    1065:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    106c:	00 
    106d:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
    1074:	00 
    1075:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
    107c:	00 
    107d:	0f 18 48 20          	prefetcht0 0x20(%rax)
    1081:	0f 18 48 60          	prefetcht0 0x60(%rax)
		.inline_on = mlx5e_xdp_get_inline_state(sq, session->inline_on),
    1085:	0f b6 4b 5e          	movzbl 0x5e(%rbx),%ecx
	u16 outstanding = sq->xdpi_fifo_pc - sq->xdpi_fifo_cc;
    1089:	8b 53 40             	mov    0x40(%rbx),%edx
    108c:	84 c9                	test   %cl,%cl
    108e:	40 0f 95 c7          	setne  %dil
    1092:	66 2b 13             	sub    (%rbx),%dx
	if (cur && outstanding <= MLX5E_XDP_INLINE_WATERMARK_LOW)
    1095:	66 83 fa 0a          	cmp    $0xa,%dx
    1099:	77 46                	ja     10e1 <mlx5e_xmit_xdp_frame_mpwqe+0x321>
    109b:	31 f6                	xor    %esi,%esi
    109d:	40 84 ff             	test   %dil,%dil
    10a0:	74 3f                	je     10e1 <mlx5e_xmit_xdp_frame_mpwqe+0x321>
	*session = (struct mlx5e_tx_mpwqe) {
    10a2:	48 89 43 50          	mov    %rax,0x50(%rbx)
    10a6:	0f b7 05 00 00 00 00 	movzwl 0x0(%rip),%eax        # 10ad <mlx5e_xmit_xdp_frame_mpwqe+0x2ed>
    10ad:	c7 43 58 00 00 00 00 	movl   $0x0,0x58(%rbx)
    10b4:	66 89 43 5c          	mov    %ax,0x5c(%rbx)
    10b8:	40 88 73 5e          	mov    %sil,0x5e(%rbx)
	stats->mpwqe++;
    10bc:	49 83 40 08 01       	addq   $0x1,0x8(%r8)
		xsk_tx_metadata_request(meta, &mlx5e_xsk_tx_metadata_ops, &session->wqe->eth);
    10c1:	48 8b 7b 50          	mov    0x50(%rbx),%rdi
	if (!meta)
    10c5:	4d 85 f6             	test   %r14,%r14
    10c8:	0f 84 69 fd ff ff    	je     e37 <mlx5e_xmit_xdp_frame_mpwqe+0x77>
		if (meta->flags & XDP_TXMD_FLAGS_CHECKSUM)
    10ce:	41 f6 06 02          	testb  $0x2,(%r14)
    10d2:	0f 84 5f fd ff ff    	je     e37 <mlx5e_xmit_xdp_frame_mpwqe+0x77>
	eseg->cs_flags |= MLX5_ETH_WQE_L3_CSUM | MLX5_ETH_WQE_L4_CSUM;
    10d8:	80 4f 14 c0          	orb    $0xc0,0x14(%rdi)
    10dc:	e9 52 fd ff ff       	jmp    e33 <mlx5e_xmit_xdp_frame_mpwqe+0x73>
	if (!cur && outstanding >= MLX5E_XDP_INLINE_WATERMARK_HIGH)
    10e1:	84 c9                	test   %cl,%cl
    10e3:	75 0b                	jne    10f0 <mlx5e_xmit_xdp_frame_mpwqe+0x330>
    10e5:	be 01 00 00 00       	mov    $0x1,%esi
    10ea:	66 83 fa 7f          	cmp    $0x7f,%dx
    10ee:	77 b2                	ja     10a2 <mlx5e_xmit_xdp_frame_mpwqe+0x2e2>
		.inline_on = mlx5e_xdp_get_inline_state(sq, session->inline_on),
    10f0:	89 fe                	mov    %edi,%esi
    10f2:	eb ae                	jmp    10a2 <mlx5e_xmit_xdp_frame_mpwqe+0x2e2>
		memcpy(inline_dseg->data, xdptxd->data, dma_len);
    10f4:	48 8b 16             	mov    (%rsi),%rdx
    10f7:	48 83 c7 0c          	add    $0xc,%rdi
    10fb:	48 89 57 f8          	mov    %rdx,-0x8(%rdi)
    10ff:	89 c2                	mov    %eax,%edx
    1101:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
    1105:	4c 8b 44 16 f8       	mov    -0x8(%rsi,%rdx,1),%r8
    110a:	4c 89 44 11 f8       	mov    %r8,-0x8(%rcx,%rdx,1)
    110f:	48 29 f9             	sub    %rdi,%rcx
    1112:	48 29 ce             	sub    %rcx,%rsi
    1115:	01 c1                	add    %eax,%ecx
    1117:	c1 e9 03             	shr    $0x3,%ecx
    111a:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
    111d:	e9 96 fe ff ff       	jmp    fb8 <mlx5e_xmit_xdp_frame_mpwqe+0x1f8>
		stats->err++;
    1122:	49 83 45 28 01       	addq   $0x1,0x28(%r13)
		return false;
    1127:	31 c0                	xor    %eax,%eax
    1129:	e9 7b fd ff ff       	jmp    ea9 <mlx5e_xmit_xdp_frame_mpwqe+0xe9>
			tmp.dma_addr = xdptxdf->dma_arr ? xdptxdf->dma_arr[0] :
    112e:	48 03 4f 20          	add    0x20(%rdi),%rcx
    1132:	e9 30 fe ff ff       	jmp    f67 <mlx5e_xmit_xdp_frame_mpwqe+0x1a7>
				mlx5e_xdp_mpwqe_complete(sq);
    1137:	48 89 df             	mov    %rbx,%rdi
    113a:	e8 00 00 00 00       	call   113f <mlx5e_xmit_xdp_frame_mpwqe+0x37f>
    113f:	e9 99 fe ff ff       	jmp    fdd <mlx5e_xmit_xdp_frame_mpwqe+0x21d>
    1144:	8b 16                	mov    (%rsi),%edx
    1146:	89 57 04             	mov    %edx,0x4(%rdi)
    1149:	89 c2                	mov    %eax,%edx
    114b:	8b 74 16 fc          	mov    -0x4(%rsi,%rdx,1),%esi
    114f:	89 74 11 fc          	mov    %esi,-0x4(%rcx,%rdx,1)
    1153:	e9 60 fe ff ff       	jmp    fb8 <mlx5e_xmit_xdp_frame_mpwqe+0x1f8>
}
    1158:	e8 00 00 00 00       	call   115d <mlx5e_xmit_xdp_frame_mpwqe+0x39d>
    115d:	0f 1f 00             	nopl   (%rax)
    1160:	90                   	nop
    1161:	90                   	nop
    1162:	90                   	nop
    1163:	90                   	nop
    1164:	90                   	nop
    1165:	90                   	nop
    1166:	90                   	nop
    1167:	90                   	nop
    1168:	90                   	nop
    1169:	90                   	nop
    116a:	90                   	nop
    116b:	90                   	nop
    116c:	90                   	nop
    116d:	90                   	nop
    116e:	90                   	nop
    116f:	90                   	nop

0000000000001170 <mlx5e_xdp_handle>:
{
    1170:	f3 0f 1e fa          	endbr64 
    1174:	e8 00 00 00 00       	call   1179 <mlx5e_xdp_handle+0x9>
    1179:	55                   	push   %rbp
    117a:	48 89 e5             	mov    %rsp,%rbp
    117d:	41 54                	push   %r12
    117f:	53                   	push   %rbx
    1180:	48 83 ec 18          	sub    $0x18,%rsp
    1184:	4c 8b 02             	mov    (%rdx),%r8
    1187:	48 8b 52 08          	mov    0x8(%rdx),%rdx
    118b:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1192:	00 00 
    1194:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    1198:	31 c0                	xor    %eax,%eax
	if ((void *)(repeat + 1) > data_end)
    119a:	49 8d 48 2e          	lea    0x2e(%r8),%rcx
    119e:	48 39 ca             	cmp    %rcx,%rdx
    11a1:	0f 82 dd 00 00 00    	jb     1284 <mlx5e_xdp_handle+0x114>
	if (eth->h_proto != htons(ETH_P_IP))
    11a7:	66 41 83 78 0c 08    	cmpw   $0x8,0xc(%r8)
    11ad:	0f 85 d1 00 00 00    	jne    1284 <mlx5e_xdp_handle+0x114>
	if (ip->protocol != IPPROTO_UDP)
    11b3:	41 80 78 17 11       	cmpb   $0x11,0x17(%r8)
    11b8:	0f 85 c6 00 00 00    	jne    1284 <mlx5e_xdp_handle+0x114>
	if (udp->dest != htons(8080))
    11be:	66 41 81 78 24 1f 90 	cmpw   $0x901f,0x24(%r8)
    11c5:	0f 85 b9 00 00 00    	jne    1284 <mlx5e_xdp_handle+0x114>
    11cb:	49 89 f4             	mov    %rsi,%r12
	if ((void *)(val + WORKING_PKT_SIZE) > data_end) {
    11ce:	49 8d 70 40          	lea    0x40(%r8),%rsi
	_repeat = *repeat;
    11d2:	45 8b 48 2a          	mov    0x2a(%r8),%r9d
	if ((void *)(val + WORKING_PKT_SIZE) > data_end) {
    11d6:	48 89 fb             	mov    %rdi,%rbx
    11d9:	48 39 f2             	cmp    %rsi,%rdx
    11dc:	0f 82 e9 00 00 00    	jb     12cb <mlx5e_xdp_handle+0x15b>
	__u64 tmp = 0;
    11e2:	31 c9                	xor    %ecx,%ecx
	for (int  i = 0; i < _repeat && i < 1024; i++) {
    11e4:	31 ff                	xor    %edi,%edi
    11e6:	45 85 c9             	test   %r9d,%r9d
    11e9:	7e 2c                	jle    1217 <mlx5e_xdp_handle+0xa7>
		for (int j = 0; j < WORKING_PKT_SIZE; j++) {
    11eb:	4c 89 c0             	mov    %r8,%rax
			tmp += val[j];
    11ee:	0f b6 10             	movzbl (%rax),%edx
		for (int j = 0; j < WORKING_PKT_SIZE; j++) {
    11f1:	48 83 c0 01          	add    $0x1,%rax
			tmp += val[j];
    11f5:	48 01 d1             	add    %rdx,%rcx
		for (int j = 0; j < WORKING_PKT_SIZE; j++) {
    11f8:	48 39 c6             	cmp    %rax,%rsi
    11fb:	75 f1                	jne    11ee <mlx5e_xdp_handle+0x7e>
	for (int  i = 0; i < _repeat && i < 1024; i++) {
    11fd:	83 c7 01             	add    $0x1,%edi
    1200:	41 39 f9             	cmp    %edi,%r9d
    1203:	7e 08                	jle    120d <mlx5e_xdp_handle+0x9d>
    1205:	81 ff ff 03 00 00    	cmp    $0x3ff,%edi
    120b:	7e de                	jle    11eb <mlx5e_xdp_handle+0x7b>
	if (tmp == 123) {
    120d:	48 83 f9 7b          	cmp    $0x7b,%rcx
    1211:	0f 84 1a 01 00 00    	je     1331 <mlx5e_xdp_handle+0x1c1>
	__sync_fetch_and_add(&counter, 1);
    1217:	f0 48 83 05 00 00 00 	lock addq $0x1,0x0(%rip)        # 1220 <mlx5e_xdp_handle+0xb0>
    121e:	00 01 

static inline ktime_t ktime_get_coarse(void)
{
	struct timespec64 ts;

	ktime_get_coarse_ts64(&ts);
    1220:	49 bc ff ff ff ff ff 	movabs $0x7fffffffffffffff,%r12
    1227:	ff ff 7f 
    122a:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
    122e:	e8 00 00 00 00       	call   1233 <mlx5e_xdp_handle+0xc3>
	return timespec64_to_ktime(ts);
    1233:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    1237:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
 *
 * Return: The ktime_t representation of the value.
 */
static inline ktime_t ktime_set(const s64 secs, const unsigned long nsecs)
{
	if (unlikely(secs >= KTIME_SEC_MAX))
    123b:	48 b9 03 7d c1 25 02 	movabs $0x225c17d03,%rcx
    1242:	00 00 00 
    1245:	48 39 c8             	cmp    %rcx,%rax
    1248:	7f 0b                	jg     1255 <mlx5e_xdp_handle+0xe5>
		return KTIME_MAX;

	return secs * NSEC_PER_SEC + (s64)nsecs;
    124a:	48 69 c0 00 ca 9a 3b 	imul   $0x3b9aca00,%rax,%rax
    1251:	4c 8d 24 10          	lea    (%rax,%rdx,1),%r12
	if (last_report == 0) {
    1255:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 125c <mlx5e_xdp_handle+0xec>
    125c:	48 85 c0             	test   %rax,%rax
    125f:	74 61                	je     12c2 <mlx5e_xdp_handle+0x152>
	delta = ts - last_report;
    1261:	4c 89 e2             	mov    %r12,%rdx
    1264:	48 29 c2             	sub    %rax,%rdx
	if (delta >= 1000000000L) {
    1267:	48 81 fa ff c9 9a 3b 	cmp    $0x3b9ac9ff,%rdx
    126e:	77 34                	ja     12a4 <mlx5e_xdp_handle+0x134>
		rq->stats->xdp_drop++;
    1270:	48 8b 83 00 01 00 00 	mov    0x100(%rbx),%rax
    1277:	48 83 80 90 00 00 00 	addq   $0x1,0x90(%rax)
    127e:	01 
		return true;
    127f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    1284:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    1288:	65 48 2b 14 25 28 00 	sub    %gs:0x28,%rdx
    128f:	00 00 
    1291:	0f 85 a8 00 00 00    	jne    133f <mlx5e_xdp_handle+0x1cf>
    1297:	48 83 c4 18          	add    $0x18,%rsp
    129b:	5b                   	pop    %rbx
    129c:	41 5c                	pop    %r12
    129e:	5d                   	pop    %rbp
    129f:	e9 00 00 00 00       	jmp    12a4 <mlx5e_xdp_handle+0x134>
		printk("throughput: %lld (pps)", counter);
    12a4:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 12ab <mlx5e_xdp_handle+0x13b>
    12ab:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    12b2:	e8 00 00 00 00       	call   12b7 <mlx5e_xdp_handle+0x147>
		counter = 0;
    12b7:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # 12c2 <mlx5e_xdp_handle+0x152>
    12be:	00 00 00 00 
		last_report = ts;
    12c2:	4c 89 25 00 00 00 00 	mov    %r12,0x0(%rip)        # 12c9 <mlx5e_xdp_handle+0x159>
	switch (act) {
    12c9:	eb a5                	jmp    1270 <mlx5e_xdp_handle+0x100>
		printk("small packet size. expect 256 B packets!");
    12cb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    12d2:	e8 00 00 00 00       	call   12d7 <mlx5e_xdp_handle+0x167>
		trace_xdp_exception(rq->netdev, prog, act);
    12d7:	48 8b b3 f8 00 00 00 	mov    0xf8(%rbx),%rsi

#ifdef CONFIG_HAVE_JUMP_LABEL_HACK

static __always_inline bool arch_static_branch(struct static_key *key, bool branch)
{
	asm goto("1:"
    12de:	eb 02                	jmp    12e2 <mlx5e_xdp_handle+0x172>
    12e0:	eb 8e                	jmp    1270 <mlx5e_xdp_handle+0x100>
	{ XDP_##x, #x },
#define __XDP_ACT_SYM_TAB	\
	__XDP_ACT_MAP(__XDP_ACT_SYM_FN) { -1, NULL }
__XDP_ACT_MAP(__XDP_ACT_TP_FN)

TRACE_EVENT(xdp_exception,
    12e2:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 12e9 <mlx5e_xdp_handle+0x179>

static __always_inline bool
arch_test_bit(unsigned long nr, const volatile unsigned long *addr)
{
	return __builtin_constant_p(nr) ? constant_test_bit(nr, addr) :
					  variable_test_bit(nr, addr);
    12e9:	89 c0                	mov    %eax,%eax
	asm volatile(__ASM_SIZE(bt) " %2,%1"
    12eb:	48 0f a3 05 00 00 00 	bt     %rax,0x0(%rip)        # 12f3 <mlx5e_xdp_handle+0x183>
    12f2:	00 
    12f3:	0f 83 77 ff ff ff    	jae    1270 <mlx5e_xdp_handle+0x100>
 * The various preempt_count add/sub methods
 */

static __always_inline void __preempt_count_add(int val)
{
	raw_cpu_add_4(pcpu_hot.preempt_count, val);
    12f9:	65 ff 05 00 00 00 00 	incl   %gs:0x0(%rip)        # 1300 <mlx5e_xdp_handle+0x190>
    1300:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1307 <mlx5e_xdp_handle+0x197>
    1307:	48 85 c0             	test   %rax,%rax
    130a:	74 0e                	je     131a <mlx5e_xdp_handle+0x1aa>
    130c:	48 8b 78 08          	mov    0x8(%rax),%rdi
    1310:	31 c9                	xor    %ecx,%ecx
    1312:	4c 89 e2             	mov    %r12,%rdx
    1315:	e8 00 00 00 00       	call   131a <mlx5e_xdp_handle+0x1aa>
 * a decrement which hits zero means we have no preempt_count and should
 * reschedule.
 */
static __always_inline bool __preempt_count_dec_and_test(void)
{
	return GEN_UNARY_RMWcc("decl", pcpu_hot.preempt_count, e,
    131a:	65 ff 0d 00 00 00 00 	decl   %gs:0x0(%rip)        # 1321 <mlx5e_xdp_handle+0x1b1>
    1321:	0f 85 49 ff ff ff    	jne    1270 <mlx5e_xdp_handle+0x100>
    1327:	e8 00 00 00 00       	call   132c <mlx5e_xdp_handle+0x1bc>
    132c:	e9 3f ff ff ff       	jmp    1270 <mlx5e_xdp_handle+0x100>
		printk("this must not have happend");
    1331:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1338:	e8 00 00 00 00       	call   133d <mlx5e_xdp_handle+0x1cd>
	switch (act) {
    133d:	eb 98                	jmp    12d7 <mlx5e_xdp_handle+0x167>
}
    133f:	e8 00 00 00 00       	call   1344 <mlx5e_xdp_handle+0x1d4>
    1344:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    134b:	00 00 00 00 
    134f:	90                   	nop
    1350:	90                   	nop
    1351:	90                   	nop
    1352:	90                   	nop
    1353:	90                   	nop
    1354:	90                   	nop
    1355:	90                   	nop
    1356:	90                   	nop
    1357:	90                   	nop
    1358:	90                   	nop
    1359:	90                   	nop
    135a:	90                   	nop
    135b:	90                   	nop
    135c:	90                   	nop
    135d:	90                   	nop
    135e:	90                   	nop
    135f:	90                   	nop

0000000000001360 <mlx5e_poll_xdpsq_cq>:

bool mlx5e_poll_xdpsq_cq(struct mlx5e_cq *cq)
{
    1360:	f3 0f 1e fa          	endbr64 
    1364:	e8 00 00 00 00       	call   1369 <mlx5e_poll_xdpsq_cq+0x9>
    1369:	55                   	push   %rbp
    136a:	48 89 e5             	mov    %rsp,%rbp
    136d:	41 57                	push   %r15
    136f:	41 56                	push   %r14
    1371:	41 55                	push   %r13
    1373:	41 54                	push   %r12
    1375:	53                   	push   %rbx
    1376:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    137d:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1384:	00 00 
    1386:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    138a:	31 c0                	xor    %eax,%eax
	struct xdp_frame_bulk bq;
	struct mlx5e_xdpsq *sq;
	struct mlx5_cqe64 *cqe;
	u32 xsk_frames = 0;
    138c:	c7 85 3c ff ff ff 00 	movl   $0x0,-0xc4(%rbp)
    1393:	00 00 00 
	bq->xa = NULL;
    1396:	48 c7 85 48 ff ff ff 	movq   $0x0,-0xb8(%rbp)
    139d:	00 00 00 00 
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    13a1:	48 8b 87 10 02 00 00 	mov    0x210(%rdi),%rax

	xdp_frame_bulk_init(&bq);

	sq = container_of(cq, struct mlx5e_xdpsq, cq);

	if (unlikely(!test_bit(MLX5E_SQ_STATE_ENABLED, &sq->state)))
    13a8:	41 89 c5             	mov    %eax,%r13d
    13ab:	41 83 e5 01          	and    $0x1,%r13d
    13af:	0f 84 22 03 00 00    	je     16d7 <mlx5e_poll_xdpsq_cq+0x377>
	ix  += fbc->strides_offset;
    13b5:	0f b7 47 0e          	movzwl 0xe(%rdi),%eax
	frag = ix >> fbc->log_frag_strides;
    13b9:	0f b6 4f 12          	movzbl 0x12(%rdi),%ecx
    13bd:	48 89 fb             	mov    %rdi,%rbx
	return wq->fbc.log_stride;
}

static inline u32 mlx5_cqwq_ctr2ix(struct mlx5_cqwq *wq, u32 ctr)
{
	return ctr & wq->fbc.sz_m1;
    13c0:	44 8b 77 20          	mov    0x20(%rdi),%r14d
    13c4:	44 23 77 08          	and    0x8(%rdi),%r14d
	ix  += fbc->strides_offset;
    13c8:	41 01 c6             	add    %eax,%r14d
	frag = ix >> fbc->log_frag_strides;
    13cb:	80 f9 1f             	cmp    $0x1f,%cl
    13ce:	0f 87 00 00 00 00    	ja     13d4 <mlx5e_poll_xdpsq_cq+0x74>
    13d4:	45 89 f4             	mov    %r14d,%r12d
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
    13d7:	0f b7 53 0c          	movzwl 0xc(%rbx),%edx
	frag = ix >> fbc->log_frag_strides;
    13db:	41 d3 ec             	shr    %cl,%r12d
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
    13de:	0f b6 4b 11          	movzbl 0x11(%rbx),%ecx
    13e2:	41 21 d6             	and    %edx,%r14d
    13e5:	89 c8                	mov    %ecx,%eax
    13e7:	80 f9 1f             	cmp    $0x1f,%cl
    13ea:	0f 87 00 00 00 00    	ja     13f0 <mlx5e_poll_xdpsq_cq+0x90>
    13f0:	49 c1 e4 04          	shl    $0x4,%r12
    13f4:	4c 03 23             	add    (%rbx),%r12
static inline struct mlx5_cqe64 *mlx5_cqwq_get_wqe(struct mlx5_cqwq *wq, u32 ix)
{
	struct mlx5_cqe64 *cqe = mlx5_frag_buf_get_wqe(&wq->fbc, ix);

	/* For 128B CQEs the data is in the last 64B */
	cqe += wq->fbc.log_stride == 7;
    13f7:	3c 07                	cmp    $0x7,%al
    13f9:	0f 94 c0             	sete   %al
    13fc:	41 d3 e6             	shl    %cl,%r14d
    13ff:	0f b6 4b 10          	movzbl 0x10(%rbx),%ecx
    1403:	0f b6 c0             	movzbl %al,%eax
    1406:	48 c1 e0 06          	shl    $0x6,%rax
    140a:	4e 8d 1c 30          	lea    (%rax,%r14,1),%r11
    140e:	4d 03 1c 24          	add    (%r12),%r11
	return ctr >> wq->fbc.log_sz;
}

static inline u32 mlx5_cqwq_get_wrap_cnt(struct mlx5_cqwq *wq)
{
	return mlx5_cqwq_get_ctr_wrap_cnt(wq, wq->cc);
    1412:	44 8b 63 20          	mov    0x20(%rbx),%r12d

static inline struct mlx5_cqe64 *mlx5_cqwq_get_cqe(struct mlx5_cqwq *wq)
{
	u32 ci = mlx5_cqwq_get_ci(wq);
	struct mlx5_cqe64 *cqe = mlx5_cqwq_get_wqe(wq, ci);
	u8 cqe_ownership_bit = cqe->op_own & MLX5_CQE_OWNER_MASK;
    1416:	41 0f b6 43 3f       	movzbl 0x3f(%r11),%eax
	return ctr >> wq->fbc.log_sz;
    141b:	80 f9 1f             	cmp    $0x1f,%cl
    141e:	0f 87 00 00 00 00    	ja     1424 <mlx5e_poll_xdpsq_cq+0xc4>
    1424:	41 d3 ec             	shr    %cl,%r12d
	u8 sw_ownership_val = mlx5_cqwq_get_wrap_cnt(wq) & 1;

	if (cqe_ownership_bit != sw_ownership_val)
    1427:	44 31 e0             	xor    %r12d,%eax
    142a:	a8 01                	test   $0x1,%al
    142c:	0f 85 a5 02 00 00    	jne    16d7 <mlx5e_poll_xdpsq_cq+0x377>
		return false;

	cqe = mlx5_cqwq_get_cqe(&cq->wq);
	if (!cqe)
    1432:	4d 85 db             	test   %r11,%r11
    1435:	0f 84 9c 02 00 00    	je     16d7 <mlx5e_poll_xdpsq_cq+0x377>
	sq = container_of(cq, struct mlx5e_xdpsq, cq);
    143b:	48 8d 43 80          	lea    -0x80(%rbx),%rax
			netdev_WARN_ONCE(sq->channel->netdev,
					 "Bad OP in XDPSQ CQE: 0x%x\n",
					 get_cqe_opcode(cqe));
			mlx5e_dump_error_cqe(&sq->cq, sq->sqn,
					     (struct mlx5_err_cqe *)cqe);
			mlx5_wq_cyc_wqe_dump(&sq->wq, ci, wi->num_wqebbs);
    143f:	44 88 ad 0f ff ff ff 	mov    %r13b,-0xf1(%rbp)
	sqcc = sq->cc;
    1446:	44 0f b7 63 84       	movzwl -0x7c(%rbx),%r12d
	i = 0;
    144b:	45 31 f6             	xor    %r14d,%r14d
	sq = container_of(cq, struct mlx5e_xdpsq, cq);
    144e:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
			mlx5_wq_cyc_wqe_dump(&sq->wq, ci, wi->num_wqebbs);
    1455:	48 8d 83 88 01 00 00 	lea    0x188(%rbx),%rax
    145c:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
	wq->cc++;
    1463:	83 43 20 01          	addl   $0x1,0x20(%rbx)
		wqe_counter = be16_to_cpu(cqe->wqe_counter);
    1467:	45 0f b7 7b 3c       	movzwl 0x3c(%r11),%r15d
    146c:	4c 89 9d 30 ff ff ff 	mov    %r11,-0xd0(%rbp)
    1473:	44 89 f8             	mov    %r15d,%eax
    1476:	44 89 b5 18 ff ff ff 	mov    %r14d,-0xe8(%rbp)
    147d:	45 89 e6             	mov    %r12d,%r14d
    1480:	49 89 dc             	mov    %rbx,%r12
    1483:	66 c1 c0 08          	rol    $0x8,%ax
    1487:	66 89 85 28 ff ff ff 	mov    %ax,-0xd8(%rbp)
	return ctr & wq->fbc.sz_m1;
    148e:	45 0f b7 ac 24 90 01 	movzwl 0x190(%r12),%r13d
    1495:	00 00 
    1497:	45 89 f7             	mov    %r14d,%r15d
			mlx5e_free_xdpsq_desc(sq, wi, &xsk_frames, &bq, cq, cqe);
    149a:	4d 89 e0             	mov    %r12,%r8
			wi = &sq->db.wqe_info[ci];
    149d:	49 8b 94 24 c8 01 00 	mov    0x1c8(%r12),%rdx
    14a4:	00 
			mlx5e_free_xdpsq_desc(sq, wi, &xsk_frames, &bq, cq, cqe);
    14a5:	4c 8b 8d 30 ff ff ff 	mov    -0xd0(%rbp),%r9
    14ac:	48 8b bd 20 ff ff ff 	mov    -0xe0(%rbp),%rdi
    14b3:	45 21 f5             	and    %r14d,%r13d
			wi = &sq->db.wqe_info[ci];
    14b6:	41 0f b7 cd          	movzwl %r13w,%ecx
    14ba:	48 8d 1c 4a          	lea    (%rdx,%rcx,2),%rbx
			mlx5e_free_xdpsq_desc(sq, wi, &xsk_frames, &bq, cq, cqe);
    14be:	48 8d 8d 40 ff ff ff 	lea    -0xc0(%rbp),%rcx
			sqcc += wi->num_wqebbs;
    14c5:	0f b6 13             	movzbl (%rbx),%edx
			mlx5e_free_xdpsq_desc(sq, wi, &xsk_frames, &bq, cq, cqe);
    14c8:	48 89 de             	mov    %rbx,%rsi
			sqcc += wi->num_wqebbs;
    14cb:	41 01 d6             	add    %edx,%r14d
			mlx5e_free_xdpsq_desc(sq, wi, &xsk_frames, &bq, cq, cqe);
    14ce:	48 8d 95 3c ff ff ff 	lea    -0xc4(%rbp),%rdx
    14d5:	e8 86 ed ff ff       	call   260 <mlx5e_free_xdpsq_desc>
		} while (!last_wqe);
    14da:	66 44 3b bd 28 ff ff 	cmp    -0xd8(%rbp),%r15w
    14e1:	ff 
    14e2:	75 aa                	jne    148e <mlx5e_poll_xdpsq_cq+0x12e>
	return cqe->op_own >> 4;
    14e4:	4c 8b 9d 30 ff ff ff 	mov    -0xd0(%rbp),%r11
    14eb:	49 89 df             	mov    %rbx,%r15
    14ee:	4c 89 e3             	mov    %r12,%rbx
    14f1:	45 89 f4             	mov    %r14d,%r12d
    14f4:	44 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%r14d
		if (unlikely(get_cqe_opcode(cqe) != MLX5_CQE_REQ)) {
    14fb:	45 0f b6 4b 3f       	movzbl 0x3f(%r11),%r9d
    1500:	41 c0 e9 04          	shr    $0x4,%r9b
    1504:	0f 85 fe 00 00 00    	jne    1608 <mlx5e_poll_xdpsq_cq+0x2a8>
		}
	} while ((++i < MLX5E_TX_CQ_POLL_BUDGET) && (cqe = mlx5_cqwq_get_cqe(&cq->wq)));
    150a:	41 83 c6 01          	add    $0x1,%r14d
    150e:	41 81 fe 80 00 00 00 	cmp    $0x80,%r14d
    1515:	0f 84 98 01 00 00    	je     16b3 <mlx5e_poll_xdpsq_cq+0x353>
	ix  += fbc->strides_offset;
    151b:	0f b7 53 0e          	movzwl 0xe(%rbx),%edx
	frag = ix >> fbc->log_frag_strides;
    151f:	0f b6 4b 12          	movzbl 0x12(%rbx),%ecx
	return ctr & wq->fbc.sz_m1;
    1523:	8b 43 20             	mov    0x20(%rbx),%eax
    1526:	23 43 08             	and    0x8(%rbx),%eax
	ix  += fbc->strides_offset;
    1529:	01 d0                	add    %edx,%eax
	frag = ix >> fbc->log_frag_strides;
    152b:	80 f9 1f             	cmp    $0x1f,%cl
    152e:	0f 87 00 00 00 00    	ja     1534 <mlx5e_poll_xdpsq_cq+0x1d4>
    1534:	41 89 c5             	mov    %eax,%r13d
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
    1537:	44 0f b7 7b 0c       	movzwl 0xc(%rbx),%r15d
	frag = ix >> fbc->log_frag_strides;
    153c:	41 d3 ed             	shr    %cl,%r13d
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
    153f:	0f b6 4b 11          	movzbl 0x11(%rbx),%ecx
    1543:	41 21 c7             	and    %eax,%r15d
    1546:	48 89 ca             	mov    %rcx,%rdx
    1549:	80 f9 1f             	cmp    $0x1f,%cl
    154c:	0f 87 00 00 00 00    	ja     1552 <mlx5e_poll_xdpsq_cq+0x1f2>
    1552:	49 c1 e5 04          	shl    $0x4,%r13
	cqe += wq->fbc.log_stride == 7;
    1556:	45 31 db             	xor    %r11d,%r11d
    1559:	4c 03 2b             	add    (%rbx),%r13
    155c:	80 fa 07             	cmp    $0x7,%dl
    155f:	41 0f 94 c3          	sete   %r11b
    1563:	41 d3 e7             	shl    %cl,%r15d
    1566:	0f b6 4b 10          	movzbl 0x10(%rbx),%ecx
    156a:	49 c1 e3 06          	shl    $0x6,%r11
    156e:	4d 01 fb             	add    %r15,%r11
    1571:	4d 03 5d 00          	add    0x0(%r13),%r11
	return mlx5_cqwq_get_ctr_wrap_cnt(wq, wq->cc);
    1575:	44 8b 6b 20          	mov    0x20(%rbx),%r13d
	u8 cqe_ownership_bit = cqe->op_own & MLX5_CQE_OWNER_MASK;
    1579:	45 0f b6 7b 3f       	movzbl 0x3f(%r11),%r15d
	return ctr >> wq->fbc.log_sz;
    157e:	80 f9 1f             	cmp    $0x1f,%cl
    1581:	0f 87 00 00 00 00    	ja     1587 <mlx5e_poll_xdpsq_cq+0x227>
    1587:	41 d3 ed             	shr    %cl,%r13d
	if (cqe_ownership_bit != sw_ownership_val)
    158a:	45 31 ef             	xor    %r13d,%r15d
    158d:	41 83 e7 01          	and    $0x1,%r15d
    1591:	75 09                	jne    159c <mlx5e_poll_xdpsq_cq+0x23c>
    1593:	4d 85 db             	test   %r11,%r11
    1596:	0f 85 c7 fe ff ff    	jne    1463 <mlx5e_poll_xdpsq_cq+0x103>
	xdp_flush_frame_bulk(&bq);

	if (xsk_frames)
		xsk_tx_completed(sq->xsk_pool, xsk_frames);

	sq->stats->cqes += i;
    159c:	4d 63 f6             	movslq %r14d,%r14
    159f:	45 31 ed             	xor    %r13d,%r13d
	xdp_flush_frame_bulk(&bq);
    15a2:	48 8d bd 40 ff ff ff 	lea    -0xc0(%rbp),%rdi
    15a9:	e8 00 00 00 00       	call   15ae <mlx5e_poll_xdpsq_cq+0x24e>
	if (xsk_frames)
    15ae:	8b b5 3c ff ff ff    	mov    -0xc4(%rbp),%esi
    15b4:	85 f6                	test   %esi,%esi
    15b6:	0f 85 0a 01 00 00    	jne    16c6 <mlx5e_poll_xdpsq_cq+0x366>
	sq->stats->cqes += i;
    15bc:	48 8b 83 b0 01 00 00 	mov    0x1b0(%rbx),%rax
    15c3:	4c 01 70 40          	add    %r14,0x40(%rax)
	*wq->db = cpu_to_be32(wq->cc & 0xffffff);
    15c7:	8b 43 20             	mov    0x20(%rbx),%eax
    15ca:	48 8b 53 18          	mov    0x18(%rbx),%rdx
    15ce:	25 ff ff ff 00       	and    $0xffffff,%eax
    15d3:	0f c8                	bswap  %eax
    15d5:	89 02                	mov    %eax,(%rdx)

	mlx5_cqwq_update_db_record(&cq->wq);

	/* ensure cq space is freed before enabling more cqes */
	wmb();
    15d7:	0f ae f8             	sfence 

	sq->cc = sqcc;
    15da:	66 44 89 63 84       	mov    %r12w,-0x7c(%rbx)
	return (i == MLX5E_TX_CQ_POLL_BUDGET);
}
    15df:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    15e3:	65 48 2b 04 25 28 00 	sub    %gs:0x28,%rax
    15ea:	00 00 
    15ec:	0f 85 3c 02 00 00    	jne    182e <mlx5e_poll_xdpsq_cq+0x4ce>
    15f2:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    15f6:	44 89 e8             	mov    %r13d,%eax
    15f9:	5b                   	pop    %rbx
    15fa:	41 5c                	pop    %r12
    15fc:	41 5d                	pop    %r13
    15fe:	41 5e                	pop    %r14
    1600:	41 5f                	pop    %r15
    1602:	5d                   	pop    %rbp
    1603:	e9 00 00 00 00       	jmp    1608 <mlx5e_poll_xdpsq_cq+0x2a8>
			netdev_WARN_ONCE(sq->channel->netdev,
    1608:	0f b6 05 00 00 00 00 	movzbl 0x0(%rip),%eax        # 160f <mlx5e_poll_xdpsq_cq+0x2af>
    160f:	3c 01                	cmp    $0x1,%al
    1611:	0f 87 00 00 00 00    	ja     1617 <mlx5e_poll_xdpsq_cq+0x2b7>
    1617:	a8 01                	test   $0x1,%al
    1619:	0f 84 c0 00 00 00    	je     16df <mlx5e_poll_xdpsq_cq+0x37f>
					struct mlx5_err_cqe *err_cqe)
{
	struct mlx5_cqwq *wq = &cq->wq;
	u32 ci;

	ci = mlx5_cqwq_ctr2ix(wq, wq->cc - 1);
    161f:	8b 43 20             	mov    0x20(%rbx),%eax

	netdev_err(cq->netdev,
    1622:	8b 53 38             	mov    0x38(%rbx),%edx
    1625:	41 83 e1 0f          	and    $0xf,%r9d
	} while ((++i < MLX5E_TX_CQ_POLL_BUDGET) && (cqe = mlx5_cqwq_get_cqe(&cq->wq)));
    1629:	41 83 c6 01          	add    $0x1,%r14d
    162d:	48 8b bb 00 01 00 00 	mov    0x100(%rbx),%rdi
    1634:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
	ci = mlx5_cqwq_ctr2ix(wq, wq->cc - 1);
    163b:	8d 48 ff             	lea    -0x1(%rax),%ecx
	netdev_err(cq->netdev,
    163e:	41 0f b6 43 36       	movzbl 0x36(%r11),%eax
	return ctr & wq->fbc.sz_m1;
    1643:	23 4b 08             	and    0x8(%rbx),%ecx
    1646:	50                   	push   %rax
    1647:	41 0f b6 43 37       	movzbl 0x37(%r11),%eax
    164c:	4c 89 9d 30 ff ff ff 	mov    %r11,-0xd0(%rbp)
    1653:	50                   	push   %rax
    1654:	44 8b 83 f8 01 00 00 	mov    0x1f8(%rbx),%r8d
    165b:	e8 00 00 00 00       	call   1660 <mlx5e_poll_xdpsq_cq+0x300>
				   struct mlx5_core_cq *cq, u16 cq_period,
				   u16 cq_max_count);
static inline void mlx5_dump_err_cqe(struct mlx5_core_dev *dev,
				     struct mlx5_err_cqe *err_cqe)
{
	print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET, 16, 1, err_cqe,
    1660:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    1666:	b9 10 00 00 00       	mov    $0x10,%ecx
    166b:	ba 02 00 00 00       	mov    $0x2,%edx
    1670:	6a 00                	push   $0x0
    1672:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1679:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1680:	6a 40                	push   $0x40
    1682:	4c 8b 8d 30 ff ff ff 	mov    -0xd0(%rbp),%r9
    1689:	e8 00 00 00 00       	call   168e <mlx5e_poll_xdpsq_cq+0x32e>
			mlx5_wq_cyc_wqe_dump(&sq->wq, ci, wi->num_wqebbs);
    168e:	41 0f b6 17          	movzbl (%r15),%edx
    1692:	48 8b bd 10 ff ff ff 	mov    -0xf0(%rbp),%rdi
    1699:	41 0f b7 f5          	movzwl %r13w,%esi
    169d:	48 83 c4 20          	add    $0x20,%rsp
    16a1:	e8 00 00 00 00       	call   16a6 <mlx5e_poll_xdpsq_cq+0x346>
	} while ((++i < MLX5E_TX_CQ_POLL_BUDGET) && (cqe = mlx5_cqwq_get_cqe(&cq->wq)));
    16a6:	41 81 fe 80 00 00 00 	cmp    $0x80,%r14d
    16ad:	0f 85 68 fe ff ff    	jne    151b <mlx5e_poll_xdpsq_cq+0x1bb>
    16b3:	44 0f b6 ad 0f ff ff 	movzbl -0xf1(%rbp),%r13d
    16ba:	ff 
    16bb:	41 be 80 00 00 00    	mov    $0x80,%r14d
    16c1:	e9 dc fe ff ff       	jmp    15a2 <mlx5e_poll_xdpsq_cq+0x242>
		xsk_tx_completed(sq->xsk_pool, xsk_frames);
    16c6:	48 8b bb 80 01 00 00 	mov    0x180(%rbx),%rdi
    16cd:	e8 00 00 00 00       	call   16d2 <mlx5e_poll_xdpsq_cq+0x372>
    16d2:	e9 e5 fe ff ff       	jmp    15bc <mlx5e_poll_xdpsq_cq+0x25c>
		return false;
    16d7:	45 31 ed             	xor    %r13d,%r13d
    16da:	e9 00 ff ff ff       	jmp    15df <mlx5e_poll_xdpsq_cq+0x27f>
			netdev_WARN_ONCE(sq->channel->netdev,
    16df:	48 8b 83 60 02 00 00 	mov    0x260(%rbx),%rax
    16e6:	c6 05 00 00 00 00 01 	movb   $0x1,0x0(%rip)        # 16ed <mlx5e_poll_xdpsq_cq+0x38d>
    16ed:	48 8b 80 a8 2a 00 00 	mov    0x2aa8(%rax),%rax
	return dev->name;
}

static inline const char *netdev_reg_state(const struct net_device *dev)
{
	switch (dev->reg_state) {
    16f4:	0f b6 90 78 05 00 00 	movzbl 0x578(%rax),%edx
    16fb:	80 fa 05             	cmp    $0x5,%dl
    16fe:	0f 87 a1 00 00 00    	ja     17a5 <mlx5e_poll_xdpsq_cq+0x445>
    1704:	48 8b 14 d5 00 00 00 	mov    0x0(,%rdx,8),%rdx
    170b:	00 
	if (!dev->name[0] || strchr(dev->name, '%'))
    170c:	80 b8 28 01 00 00 00 	cmpb   $0x0,0x128(%rax)
		return "(unnamed net_device)";
    1713:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	if (!dev->name[0] || strchr(dev->name, '%'))
    171a:	74 58                	je     1774 <mlx5e_poll_xdpsq_cq+0x414>
    171c:	48 8d b8 28 01 00 00 	lea    0x128(%rax),%rdi
    1723:	be 25 00 00 00       	mov    $0x25,%esi
    1728:	4c 89 9d 00 ff ff ff 	mov    %r11,-0x100(%rbp)
    172f:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
    1736:	44 88 8d 28 ff ff ff 	mov    %r9b,-0xd8(%rbp)
    173d:	48 89 bd 30 ff ff ff 	mov    %rdi,-0xd0(%rbp)
    1744:	e8 00 00 00 00       	call   1749 <mlx5e_poll_xdpsq_cq+0x3e9>
		return "(unnamed net_device)";
    1749:	48 8b bd 30 ff ff ff 	mov    -0xd0(%rbp),%rdi
    1750:	4c 8b 9d 00 ff ff ff 	mov    -0x100(%rbp),%r11
    1757:	48 85 c0             	test   %rax,%rax
    175a:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
    1761:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
    1768:	44 0f b6 8d 28 ff ff 	movzbl -0xd8(%rbp),%r9d
    176f:	ff 
    1770:	48 0f 45 f8          	cmovne %rax,%rdi
    1774:	48 89 fe             	mov    %rdi,%rsi
    1777:	41 0f b6 c9          	movzbl %r9b,%ecx
    177b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1782:	4c 89 9d 30 ff ff ff 	mov    %r11,-0xd0(%rbp)
    1789:	e8 00 00 00 00       	call   178e <mlx5e_poll_xdpsq_cq+0x42e>
    178e:	0f 0b                	ud2    
    1790:	4c 8b 9d 30 ff ff ff 	mov    -0xd0(%rbp),%r11
    1797:	45 0f b6 4b 3f       	movzbl 0x3f(%r11),%r9d
    179c:	41 c0 e9 04          	shr    $0x4,%r9b
    17a0:	e9 7a fe ff ff       	jmp    161f <mlx5e_poll_xdpsq_cq+0x2bf>
	case NETREG_UNREGISTERED: return " (unregistered)";
	case NETREG_RELEASED: return " (released)";
	case NETREG_DUMMY: return " (dummy)";
	}

	WARN_ONCE(1, "%s: unknown reg_state %d\n", dev->name, dev->reg_state);
    17a5:	0f b6 15 00 00 00 00 	movzbl 0x0(%rip),%edx        # 17ac <mlx5e_poll_xdpsq_cq+0x44c>
    17ac:	80 fa 01             	cmp    $0x1,%dl
    17af:	0f 87 00 00 00 00    	ja     17b5 <mlx5e_poll_xdpsq_cq+0x455>
    17b5:	83 e2 01             	and    $0x1,%edx
    17b8:	74 1a                	je     17d4 <mlx5e_poll_xdpsq_cq+0x474>
    17ba:	48 8b 83 60 02 00 00 	mov    0x260(%rbx),%rax
	return " (unknown)";
    17c1:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    17c8:	48 8b 80 a8 2a 00 00 	mov    0x2aa8(%rax),%rax
    17cf:	e9 38 ff ff ff       	jmp    170c <mlx5e_poll_xdpsq_cq+0x3ac>
	WARN_ONCE(1, "%s: unknown reg_state %d\n", dev->name, dev->reg_state);
    17d4:	0f b6 90 78 05 00 00 	movzbl 0x578(%rax),%edx
    17db:	48 8d b0 28 01 00 00 	lea    0x128(%rax),%rsi
    17e2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    17e9:	4c 89 9d 28 ff ff ff 	mov    %r11,-0xd8(%rbp)
    17f0:	44 88 8d 30 ff ff ff 	mov    %r9b,-0xd0(%rbp)
    17f7:	c6 05 00 00 00 00 01 	movb   $0x1,0x0(%rip)        # 17fe <mlx5e_poll_xdpsq_cq+0x49e>
    17fe:	e8 00 00 00 00       	call   1803 <mlx5e_poll_xdpsq_cq+0x4a3>
    1803:	0f 0b                	ud2    
    1805:	48 8b 83 60 02 00 00 	mov    0x260(%rbx),%rax
	return " (unknown)";
    180c:	4c 8b 9d 28 ff ff ff 	mov    -0xd8(%rbp),%r11
    1813:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
    181a:	44 0f b6 8d 30 ff ff 	movzbl -0xd0(%rbp),%r9d
    1821:	ff 
    1822:	48 8b 80 a8 2a 00 00 	mov    0x2aa8(%rax),%rax
    1829:	e9 de fe ff ff       	jmp    170c <mlx5e_poll_xdpsq_cq+0x3ac>
}
    182e:	e8 00 00 00 00       	call   1833 <mlx5e_poll_xdpsq_cq+0x4d3>
    1833:	66 66 2e 0f 1f 84 00 	data16 cs nopw 0x0(%rax,%rax,1)
    183a:	00 00 00 00 
    183e:	66 90                	xchg   %ax,%ax
    1840:	90                   	nop
    1841:	90                   	nop
    1842:	90                   	nop
    1843:	90                   	nop
    1844:	90                   	nop
    1845:	90                   	nop
    1846:	90                   	nop
    1847:	90                   	nop
    1848:	90                   	nop
    1849:	90                   	nop
    184a:	90                   	nop
    184b:	90                   	nop
    184c:	90                   	nop
    184d:	90                   	nop
    184e:	90                   	nop
    184f:	90                   	nop

0000000000001850 <mlx5e_free_xdpsq_descs>:

void mlx5e_free_xdpsq_descs(struct mlx5e_xdpsq *sq)
{
    1850:	f3 0f 1e fa          	endbr64 
    1854:	e8 00 00 00 00       	call   1859 <mlx5e_free_xdpsq_descs+0x9>
    1859:	55                   	push   %rbp
    185a:	48 89 e5             	mov    %rsp,%rbp
    185d:	41 54                	push   %r12
    185f:	53                   	push   %rbx
    1860:	48 89 fb             	mov    %rdi,%rbx
    1863:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
    186a:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1871:	00 00 
    1873:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    1877:	31 c0                	xor    %eax,%eax
	struct xdp_frame_bulk bq;
	u32 xsk_frames = 0;
    1879:	c7 85 54 ff ff ff 00 	movl   $0x0,-0xac(%rbp)
    1880:	00 00 00 
    1883:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
    188a:	00 00 00 00 
 * read-side critical sections may be preempted and they may also block, but
 * only when acquiring spinlocks that are subject to priority inheritance.
 */
static __always_inline void rcu_read_lock(void)
{
	__rcu_read_lock();
    188e:	e8 00 00 00 00       	call   1893 <mlx5e_free_xdpsq_descs+0x43>

	xdp_frame_bulk_init(&bq);

	rcu_read_lock(); /* need for xdp_return_frame_bulk */

	while (sq->cc != sq->pc) {
    1893:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
    1897:	66 3b 43 44          	cmp    0x44(%rbx),%ax
    189b:	0f 84 91 00 00 00    	je     1932 <mlx5e_free_xdpsq_descs+0xe2>
	return ctr & wq->fbc.sz_m1;
    18a1:	0f b7 93 10 02 00 00 	movzwl 0x210(%rbx),%edx
		ci = mlx5_wq_cyc_ctr2ix(&sq->wq, sq->cc);
		wi = &sq->db.wqe_info[ci];

		sq->cc += wi->num_wqebbs;

		mlx5e_free_xdpsq_desc(sq, wi, &xsk_frames, &bq, NULL, NULL);
    18a8:	45 31 c9             	xor    %r9d,%r9d
    18ab:	45 31 c0             	xor    %r8d,%r8d
    18ae:	48 89 df             	mov    %rbx,%rdi
		wi = &sq->db.wqe_info[ci];
    18b1:	48 8b 8b 48 02 00 00 	mov    0x248(%rbx),%rcx
    18b8:	21 c2                	and    %eax,%edx
    18ba:	0f b7 d2             	movzwl %dx,%edx
    18bd:	48 8d 34 51          	lea    (%rcx,%rdx,2),%rsi
		mlx5e_free_xdpsq_desc(sq, wi, &xsk_frames, &bq, NULL, NULL);
    18c1:	48 8d 8d 58 ff ff ff 	lea    -0xa8(%rbp),%rcx
		sq->cc += wi->num_wqebbs;
    18c8:	0f b6 16             	movzbl (%rsi),%edx
    18cb:	01 d0                	add    %edx,%eax
		mlx5e_free_xdpsq_desc(sq, wi, &xsk_frames, &bq, NULL, NULL);
    18cd:	48 8d 95 54 ff ff ff 	lea    -0xac(%rbp),%rdx
		sq->cc += wi->num_wqebbs;
    18d4:	66 89 43 04          	mov    %ax,0x4(%rbx)
		mlx5e_free_xdpsq_desc(sq, wi, &xsk_frames, &bq, NULL, NULL);
    18d8:	e8 83 e9 ff ff       	call   260 <mlx5e_free_xdpsq_desc>
	while (sq->cc != sq->pc) {
    18dd:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
    18e1:	66 3b 43 44          	cmp    0x44(%rbx),%ax
    18e5:	75 ba                	jne    18a1 <mlx5e_free_xdpsq_descs+0x51>
	}

	xdp_flush_frame_bulk(&bq);
	rcu_read_unlock();

	if (xsk_frames)
    18e7:	44 8b a5 54 ff ff ff 	mov    -0xac(%rbp),%r12d
	xdp_flush_frame_bulk(&bq);
    18ee:	48 8d bd 58 ff ff ff 	lea    -0xa8(%rbp),%rdi
    18f5:	e8 00 00 00 00       	call   18fa <mlx5e_free_xdpsq_descs+0xaa>
static inline void rcu_read_unlock(void)
{
	RCU_LOCKDEP_WARN(!rcu_is_watching(),
			 "rcu_read_unlock() used illegally while idle");
	__release(RCU);
	__rcu_read_unlock();
    18fa:	e8 00 00 00 00       	call   18ff <mlx5e_free_xdpsq_descs+0xaf>
	if (xsk_frames)
    18ff:	45 85 e4             	test   %r12d,%r12d
    1902:	74 0f                	je     1913 <mlx5e_free_xdpsq_descs+0xc3>
		xsk_tx_completed(sq->xsk_pool, xsk_frames);
    1904:	48 8b bb 00 02 00 00 	mov    0x200(%rbx),%rdi
    190b:	44 89 e6             	mov    %r12d,%esi
    190e:	e8 00 00 00 00       	call   1913 <mlx5e_free_xdpsq_descs+0xc3>
}
    1913:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    1917:	65 48 2b 04 25 28 00 	sub    %gs:0x28,%rax
    191e:	00 00 
    1920:	75 23                	jne    1945 <mlx5e_free_xdpsq_descs+0xf5>
    1922:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
    1929:	5b                   	pop    %rbx
    192a:	41 5c                	pop    %r12
    192c:	5d                   	pop    %rbp
    192d:	e9 00 00 00 00       	jmp    1932 <mlx5e_free_xdpsq_descs+0xe2>
	xdp_flush_frame_bulk(&bq);
    1932:	48 8d bd 58 ff ff ff 	lea    -0xa8(%rbp),%rdi
    1939:	e8 00 00 00 00       	call   193e <mlx5e_free_xdpsq_descs+0xee>
    193e:	e8 00 00 00 00       	call   1943 <mlx5e_free_xdpsq_descs+0xf3>
	if (xsk_frames)
    1943:	eb ce                	jmp    1913 <mlx5e_free_xdpsq_descs+0xc3>
}
    1945:	e8 00 00 00 00       	call   194a <mlx5e_free_xdpsq_descs+0xfa>
    194a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    1950:	90                   	nop
    1951:	90                   	nop
    1952:	90                   	nop
    1953:	90                   	nop
    1954:	90                   	nop
    1955:	90                   	nop
    1956:	90                   	nop
    1957:	90                   	nop
    1958:	90                   	nop
    1959:	90                   	nop
    195a:	90                   	nop
    195b:	90                   	nop
    195c:	90                   	nop
    195d:	90                   	nop
    195e:	90                   	nop
    195f:	90                   	nop

0000000000001960 <mlx5e_xdp_xmit>:

int mlx5e_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames,
		   u32 flags)
{
    1960:	f3 0f 1e fa          	endbr64 
    1964:	e8 00 00 00 00       	call   1969 <mlx5e_xdp_xmit+0x9>
    1969:	55                   	push   %rbp
    196a:	48 89 e5             	mov    %rsp,%rbp
    196d:	41 57                	push   %r15
    196f:	41 56                	push   %r14
    1971:	41 55                	push   %r13
    1973:	41 54                	push   %r12
    1975:	53                   	push   %rbx
    1976:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
    197d:	89 8d fc fe ff ff    	mov    %ecx,-0x104(%rbp)
    1983:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    198a:	00 00 
    198c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    1990:	48 8b 87 30 0a 00 00 	mov    0xa30(%rdi),%rax
	int nxmit = 0;
	int sq_num;
	int i;

	/* this flag is sufficient, no need to test internal sq state */
	if (unlikely(!mlx5e_xdp_tx_is_enabled(priv)))
    1997:	a8 04                	test   $0x4,%al
    1999:	0f 84 df 06 00 00    	je     207e <mlx5e_xdp_xmit+0x71e>
		return -ENETDOWN;

	if (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))
    199f:	83 f9 01             	cmp    $0x1,%ecx
    19a2:	0f 87 e1 06 00 00    	ja     2089 <mlx5e_xdp_xmit+0x729>
		return -EINVAL;

	sq_num = smp_processor_id();
    19a8:	65 8b 05 00 00 00 00 	mov    %gs:0x0(%rip),%eax        # 19af <mlx5e_xdp_xmit+0x4f>

	if (unlikely(sq_num >= priv->channels.num))
    19af:	3b 87 10 10 00 00    	cmp    0x1010(%rdi),%eax
    19b5:	0f 83 d9 06 00 00    	jae    2094 <mlx5e_xdp_xmit+0x734>
		return -ENXIO;

	sq = &priv->channels.c[sq_num]->xdpsq;
    19bb:	48 8b 8f 00 10 00 00 	mov    0x1000(%rdi),%rcx
    19c2:	48 98                	cltq   
	int nxmit = 0;
    19c4:	45 31 f6             	xor    %r14d,%r14d
	sq = &priv->channels.c[sq_num]->xdpsq;
    19c7:	48 8b 1c c1          	mov    (%rcx,%rax,8),%rbx
    19cb:	48 8d 83 c0 2a 00 00 	lea    0x2ac0(%rbx),%rax
    19d2:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)

	for (i = 0; i < n; i++) {
    19d9:	85 f6                	test   %esi,%esi
    19db:	0f 8e e1 01 00 00    	jle    1bc2 <mlx5e_xdp_xmit+0x262>
    19e1:	44 89 b5 18 ff ff ff 	mov    %r14d,-0xe8(%rbp)
    19e8:	49 89 d5             	mov    %rdx,%r13
    19eb:	41 89 f4             	mov    %esi,%r12d
		struct mlx5e_xmit_data_frags xdptxdf = {};
    19ee:	48 c7 85 28 ff ff ff 	movq   $0x0,-0xd8(%rbp)
    19f5:	00 00 00 00 

		xdptxd = &xdptxdf.xd;
		xdptxd->data = xdpf->data;
		xdptxd->len = xdpf->len;
		xdptxd->has_frags = xdp_frame_has_frags(xdpf);
		xdptxd->dma_addr = dma_map_single(sq->pdev, xdptxd->data,
    19f9:	4c 8b bb 40 2d 00 00 	mov    0x2d40(%rbx),%r15
		struct mlx5e_xmit_data_frags xdptxdf = {};
    1a00:	48 c7 85 30 ff ff ff 	movq   $0x0,-0xd0(%rbp)
    1a07:	00 00 00 00 
    1a0b:	48 c7 85 20 ff ff ff 	movq   $0x0,-0xe0(%rbp)
    1a12:	00 00 00 00 
    1a16:	48 c7 85 38 ff ff ff 	movq   $0x0,-0xc8(%rbp)
    1a1d:	00 00 00 00 
    1a21:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
    1a28:	00 00 00 00 
		struct xdp_frame *xdpf = frames[i];
    1a2c:	4d 8b 55 00          	mov    0x0(%r13),%r10
		xdptxd->data = xdpf->data;
    1a30:	4d 8b 32             	mov    (%r10),%r14
		xdptxd->len = xdpf->len;
    1a33:	41 8b 42 24          	mov    0x24(%r10),%eax
    1a37:	4c 89 95 08 ff ff ff 	mov    %r10,-0xf8(%rbp)
		xdptxd->data = xdpf->data;
    1a3e:	4c 89 b5 28 ff ff ff 	mov    %r14,-0xd8(%rbp)
		xdptxd->len = xdpf->len;
    1a45:	41 0f b7 72 08       	movzwl 0x8(%r10),%esi
    1a4a:	c1 e0 1f             	shl    $0x1f,%eax
	if (dev_WARN_ONCE(dev, is_vmalloc_addr(ptr),
    1a4d:	4c 89 f7             	mov    %r14,%rdi
    1a50:	09 f0                	or     %esi,%eax
		xdptxd->dma_addr = dma_map_single(sq->pdev, xdptxd->data,
    1a52:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
		xdptxd->len = xdpf->len;
    1a59:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%rbp)
    1a5f:	e8 00 00 00 00       	call   1a64 <mlx5e_xdp_xmit+0x104>
    1a64:	48 8b 8d 10 ff ff ff 	mov    -0xf0(%rbp),%rcx
    1a6b:	4c 8b 95 08 ff ff ff 	mov    -0xf8(%rbp),%r10
    1a72:	84 c0                	test   %al,%al
    1a74:	0f 85 a1 04 00 00    	jne    1f1b <mlx5e_xdp_xmit+0x5bb>
	return dma_map_page_attrs(dev, virt_to_page(ptr), offset_in_page(ptr),
    1a7a:	4c 89 f0             	mov    %r14,%rax
    1a7d:	ba 00 00 00 80       	mov    $0x80000000,%edx
    1a82:	25 ff 0f 00 00       	and    $0xfff,%eax
extern unsigned long vmalloc_base;
extern unsigned long vmemmap_base;

static __always_inline unsigned long __phys_addr_nodebug(unsigned long x)
{
	unsigned long y = x - __START_KERNEL_map;
    1a87:	4c 01 f2             	add    %r14,%rdx
    1a8a:	0f 82 cb 06 00 00    	jb     215b <mlx5e_xdp_xmit+0x7fb>

	/* use the carry flag to determine if x was < __START_KERNEL_map */
	x = y + ((x > y) ? phys_base : (__START_KERNEL_map - PAGE_OFFSET));
    1a90:	48 c7 c6 00 00 00 80 	mov    $0xffffffff80000000,%rsi
    1a97:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # 1a9e <mlx5e_xdp_xmit+0x13e>
    1a9e:	48 01 d6             	add    %rdx,%rsi
    1aa1:	45 31 c9             	xor    %r9d,%r9d
    1aa4:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    1aaa:	48 89 c2             	mov    %rax,%rdx
    1aad:	48 c1 ee 0c          	shr    $0xc,%rsi
    1ab1:	4c 89 ff             	mov    %r15,%rdi
    1ab4:	4c 89 95 10 ff ff ff 	mov    %r10,-0xf0(%rbp)
    1abb:	48 c1 e6 06          	shl    $0x6,%rsi
    1abf:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # 1ac6 <mlx5e_xdp_xmit+0x166>
    1ac6:	e8 00 00 00 00       	call   1acb <mlx5e_xdp_xmit+0x16b>
		xdptxd->dma_addr = dma_map_single(sq->pdev, xdptxd->data,
    1acb:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
	if (unlikely(dma_addr == DMA_MAPPING_ERROR))
    1ad2:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
    1ad6:	0f 84 d9 05 00 00    	je     20b5 <mlx5e_xdp_xmit+0x755>
						  xdptxd->len, DMA_TO_DEVICE);

		if (unlikely(dma_mapping_error(sq->pdev, xdptxd->dma_addr)))
			break;

		if (xdptxd->has_frags) {
    1adc:	80 bd 33 ff ff ff 00 	cmpb   $0x0,-0xcd(%rbp)
    1ae3:	4c 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%r10
    1aea:	0f 88 5d 01 00 00    	js     1c4d <mlx5e_xdp_xmit+0x2ed>
							 DMA_TO_DEVICE);
				goto out;
			}
		}

		ret = INDIRECT_CALL_2(sq->xmit_xdp_frame, mlx5e_xmit_xdp_frame_mpwqe,
    1af0:	48 8b 83 00 2d 00 00 	mov    0x2d00(%rbx),%rax
    1af7:	4c 89 95 10 ff ff ff 	mov    %r10,-0xf0(%rbp)
    1afe:	31 c9                	xor    %ecx,%ecx
    1b00:	31 d2                	xor    %edx,%edx
    1b02:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
    1b09:	48 8d b5 20 ff ff ff 	lea    -0xe0(%rbp),%rsi
    1b10:	48 3d 00 00 00 00    	cmp    $0x0,%rax
    1b16:	0f 85 76 04 00 00    	jne    1f92 <mlx5e_xdp_xmit+0x632>
    1b1c:	e8 00 00 00 00       	call   1b21 <mlx5e_xdp_xmit+0x1c1>
    1b21:	4c 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%r10
				      mlx5e_xmit_xdp_frame, sq, xdptxd, 0, NULL);
		if (unlikely(!ret)) {
    1b28:	84 c0                	test   %al,%al
    1b2a:	0f 84 82 04 00 00    	je     1fb2 <mlx5e_xdp_xmit+0x652>
	u32 i = (*fifo->pc)++ & fifo->mask;
    1b30:	48 8b 93 20 2d 00 00 	mov    0x2d20(%rbx),%rdx
    1b37:	8b 02                	mov    (%rdx),%eax
    1b39:	8d 48 01             	lea    0x1(%rax),%ecx
    1b3c:	89 0a                	mov    %ecx,(%rdx)
	fifo->xi[i] = xi;
    1b3e:	48 8b 93 10 2d 00 00 	mov    0x2d10(%rbx),%rdx
    1b45:	23 83 28 2d 00 00    	and    0x2d28(%rbx),%eax
    1b4b:	48 c7 04 c2 00 00 00 	movq   $0x0,(%rdx,%rax,8)
    1b52:	00 
	u32 i = (*fifo->pc)++ & fifo->mask;
    1b53:	48 8b 93 20 2d 00 00 	mov    0x2d20(%rbx),%rdx
    1b5a:	8b 02                	mov    (%rdx),%eax
    1b5c:	8d 48 01             	lea    0x1(%rax),%ecx
    1b5f:	89 0a                	mov    %ecx,(%rdx)
	fifo->xi[i] = xi;
    1b61:	48 8b 93 10 2d 00 00 	mov    0x2d10(%rbx),%rdx
    1b68:	23 83 28 2d 00 00    	and    0x2d28(%rbx),%eax
    1b6e:	4c 89 14 c2          	mov    %r10,(%rdx,%rax,8)
	u32 i = (*fifo->pc)++ & fifo->mask;
    1b72:	48 8b 93 20 2d 00 00 	mov    0x2d20(%rbx),%rdx
		mlx5e_xdpi_fifo_push(&sq->db.xdpi_fifo,
				     (union mlx5e_xdp_info) { .mode = MLX5E_XDP_XMIT_MODE_FRAME });
		mlx5e_xdpi_fifo_push(&sq->db.xdpi_fifo,
				     (union mlx5e_xdp_info) { .frame.xdpf = xdpf });
		mlx5e_xdpi_fifo_push(&sq->db.xdpi_fifo,
				     (union mlx5e_xdp_info) { .frame.dma_addr = xdptxd->dma_addr });
    1b79:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
    1b80:	8b 02                	mov    (%rdx),%eax
    1b82:	8d 70 01             	lea    0x1(%rax),%esi
    1b85:	89 32                	mov    %esi,(%rdx)
	fifo->xi[i] = xi;
    1b87:	48 8b 93 10 2d 00 00 	mov    0x2d10(%rbx),%rdx
    1b8e:	23 83 28 2d 00 00    	and    0x2d28(%rbx),%eax
    1b94:	48 89 0c c2          	mov    %rcx,(%rdx,%rax,8)
		if (xdptxd->has_frags) {
    1b98:	80 bd 33 ff ff ff 00 	cmpb   $0x0,-0xcd(%rbp)
    1b9f:	0f 88 ad 02 00 00    	js     1e52 <mlx5e_xdp_xmit+0x4f2>
			for (j = 0; j < xdptxdf.sinfo->nr_frags; j++)
				mlx5e_xdpi_fifo_push(&sq->db.xdpi_fifo,
						     (union mlx5e_xdp_info)
						     { .frame.dma_addr = dma_arr[j] });
		}
		nxmit++;
    1ba5:	83 85 18 ff ff ff 01 	addl   $0x1,-0xe8(%rbp)
    1bac:	8b 85 18 ff ff ff    	mov    -0xe8(%rbp),%eax
	for (i = 0; i < n; i++) {
    1bb2:	49 83 c5 08          	add    $0x8,%r13
    1bb6:	41 39 c4             	cmp    %eax,%r12d
    1bb9:	0f 85 2f fe ff ff    	jne    19ee <mlx5e_xdp_xmit+0x8e>
	}

out:
    1bbf:	41 89 c6             	mov    %eax,%r14d
	if (sq->mpwqe.wqe)
    1bc2:	48 83 bb 10 2b 00 00 	cmpq   $0x0,0x2b10(%rbx)
    1bc9:	00 
    1bca:	74 0c                	je     1bd8 <mlx5e_xdp_xmit+0x278>
		mlx5e_xdp_mpwqe_complete(sq);
    1bcc:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
    1bd3:	e8 00 00 00 00       	call   1bd8 <mlx5e_xdp_xmit+0x278>

	if (flags & XDP_XMIT_FLUSH)
    1bd8:	8b 85 fc fe ff ff    	mov    -0x104(%rbp),%eax
    1bde:	85 c0                	test   %eax,%eax
    1be0:	75 2c                	jne    1c0e <mlx5e_xdp_xmit+0x2ae>
		mlx5e_xmit_xdp_doorbell(sq);

	return nxmit;
}
    1be2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    1be6:	65 48 2b 04 25 28 00 	sub    %gs:0x28,%rax
    1bed:	00 00 
    1bef:	0f 85 72 05 00 00    	jne    2167 <mlx5e_xdp_xmit+0x807>
    1bf5:	48 81 c4 f0 00 00 00 	add    $0xf0,%rsp
    1bfc:	44 89 f0             	mov    %r14d,%eax
    1bff:	5b                   	pop    %rbx
    1c00:	41 5c                	pop    %r12
    1c02:	41 5d                	pop    %r13
    1c04:	41 5e                	pop    %r14
    1c06:	41 5f                	pop    %r15
    1c08:	5d                   	pop    %rbp
    1c09:	e9 00 00 00 00       	jmp    1c0e <mlx5e_xdp_xmit+0x2ae>
	if (sq->doorbell_cseg) {
    1c0e:	48 8b 93 08 2b 00 00 	mov    0x2b08(%rbx),%rdx
    1c15:	48 85 d2             	test   %rdx,%rdx
    1c18:	74 c8                	je     1be2 <mlx5e_xdp_xmit+0x282>
		mlx5e_notify_hw(&sq->wq, sq->pc, sq->uar_map, sq->doorbell_cseg);
    1c1a:	48 8b 8b 30 2d 00 00 	mov    0x2d30(%rbx),%rcx
    1c21:	0f b7 83 04 2b 00 00 	movzwl 0x2b04(%rbx),%eax
	ctrl->fm_ce_se |= MLX5_WQE_CTRL_CQ_UPDATE;
    1c28:	80 4a 0b 08          	orb    $0x8,0xb(%rdx)
	*wq->db = cpu_to_be32(pc);
    1c2c:	48 8b b3 e0 2c 00 00 	mov    0x2ce0(%rbx),%rsi
    1c33:	0f c8                	bswap  %eax
    1c35:	89 06                	mov    %eax,(%rsi)
	wmb();
    1c37:	0f ae f8             	sfence 
    1c3a:	48 8b 02             	mov    (%rdx),%rax
    1c3d:	48 89 01             	mov    %rax,(%rcx)
		sq->doorbell_cseg = NULL;
    1c40:	48 c7 83 08 2b 00 00 	movq   $0x0,0x2b08(%rbx)
    1c47:	00 00 00 00 
    1c4b:	eb 95                	jmp    1be2 <mlx5e_xdp_xmit+0x282>
	return (struct skb_shared_info *)(data_hard_start + frame->frame_sz -
    1c4d:	41 8b 52 20          	mov    0x20(%r10),%edx
	void *data_hard_start = frame->data - frame->headroom - sizeof(*frame);
    1c51:	41 0f b7 42 0a       	movzwl 0xa(%r10),%eax
	return (struct skb_shared_info *)(data_hard_start + frame->frame_sz -
    1c56:	48 81 ea 68 01 00 00 	sub    $0x168,%rdx
    1c5d:	48 29 c2             	sub    %rax,%rdx
			xdptxdf.dma_arr = dma_arr;
    1c60:	48 8d 85 48 ff ff ff 	lea    -0xb8(%rbp),%rax
    1c67:	49 03 12             	add    (%r10),%rdx
			xdptxdf.sinfo = xdp_get_shared_info_from_frame(xdpf);
    1c6a:	48 89 95 38 ff ff ff 	mov    %rdx,-0xc8(%rbp)
			xdptxdf.dma_arr = dma_arr;
    1c71:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
			for (j = 0; j < xdptxdf.sinfo->nr_frags; j++) {
    1c78:	80 7a 02 00          	cmpb   $0x0,0x2(%rdx)
    1c7c:	0f 84 6e fe ff ff    	je     1af0 <mlx5e_xdp_xmit+0x190>
    1c82:	48 89 9d 10 ff ff ff 	mov    %rbx,-0xf0(%rbp)
    1c89:	45 31 ff             	xor    %r15d,%r15d
    1c8c:	49 89 d6             	mov    %rdx,%r14
    1c8f:	4c 89 ad 08 ff ff ff 	mov    %r13,-0xf8(%rbp)
    1c96:	4c 89 95 f0 fe ff ff 	mov    %r10,-0x110(%rbp)
    1c9d:	44 89 a5 f8 fe ff ff 	mov    %r12d,-0x108(%rbp)
    1ca4:	e9 82 00 00 00       	jmp    1d2b <mlx5e_xdp_xmit+0x3cb>
	return dma_map_page_attrs(dev, virt_to_page(ptr), offset_in_page(ptr),
    1ca9:	48 89 d8             	mov    %rbx,%rax
    1cac:	ba 00 00 00 80       	mov    $0x80000000,%edx
    1cb1:	25 ff 0f 00 00       	and    $0xfff,%eax
	unsigned long y = x - __START_KERNEL_map;
    1cb6:	48 01 da             	add    %rbx,%rdx
    1cb9:	0f 82 5d 04 00 00    	jb     211c <mlx5e_xdp_xmit+0x7bc>
	x = y + ((x > y) ? phys_base : (__START_KERNEL_map - PAGE_OFFSET));
    1cbf:	48 c7 c6 00 00 00 80 	mov    $0xffffffff80000000,%rsi
    1cc6:	48 2b 35 00 00 00 00 	sub    0x0(%rip),%rsi        # 1ccd <mlx5e_xdp_xmit+0x36d>
    1ccd:	48 01 d6             	add    %rdx,%rsi
    1cd0:	45 31 c9             	xor    %r9d,%r9d
    1cd3:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    1cd9:	4c 89 e9             	mov    %r13,%rcx
    1cdc:	48 c1 ee 0c          	shr    $0xc,%rsi
    1ce0:	48 89 c2             	mov    %rax,%rdx
    1ce3:	4c 89 f7             	mov    %r14,%rdi
    1ce6:	48 c1 e6 06          	shl    $0x6,%rsi
    1cea:	48 03 35 00 00 00 00 	add    0x0(%rip),%rsi        # 1cf1 <mlx5e_xdp_xmit+0x391>
    1cf1:	e8 00 00 00 00       	call   1cf6 <mlx5e_xdp_xmit+0x396>
				dma_arr[j] = dma_map_single(sq->pdev, skb_frag_address(frag),
    1cf6:	4a 89 84 e5 48 ff ff 	mov    %rax,-0xb8(%rbp,%r12,8)
    1cfd:	ff 
				if (!dma_mapping_error(sq->pdev, dma_arr[j]))
    1cfe:	49 83 fc 10          	cmp    $0x10,%r12
    1d02:	0f 87 de 03 00 00    	ja     20e6 <mlx5e_xdp_xmit+0x786>
	if (unlikely(dma_addr == DMA_MAPPING_ERROR))
    1d08:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
    1d0c:	0f 84 8d 03 00 00    	je     209f <mlx5e_xdp_xmit+0x73f>
			for (j = 0; j < xdptxdf.sinfo->nr_frags; j++) {
    1d12:	4c 8b b5 38 ff ff ff 	mov    -0xc8(%rbp),%r14
    1d19:	41 83 c7 01          	add    $0x1,%r15d
    1d1d:	41 0f b6 46 02       	movzbl 0x2(%r14),%eax
    1d22:	44 39 f8             	cmp    %r15d,%eax
    1d25:	0f 8e 32 03 00 00    	jle    205d <mlx5e_xdp_xmit+0x6fd>
				skb_frag_t *frag = &xdptxdf.sinfo->frags[j];
    1d2b:	4d 63 e7             	movslq %r15d,%r12
    1d2e:	49 83 fc 11          	cmp    $0x11,%r12
    1d32:	0f 87 9a 03 00 00    	ja     20d2 <mlx5e_xdp_xmit+0x772>
	return frag->bv_len;
    1d38:	4c 89 e0             	mov    %r12,%rax
    1d3b:	48 c1 e0 04          	shl    $0x4,%rax
    1d3f:	4c 01 f0             	add    %r14,%rax
    1d42:	48 8b 50 30          	mov    0x30(%rax),%rdx
    1d46:	48 2b 15 00 00 00 00 	sub    0x0(%rip),%rdx        # 1d4d <mlx5e_xdp_xmit+0x3ed>
				dma_arr[j] = dma_map_single(sq->pdev, skb_frag_address(frag),
    1d4d:	44 8b 68 38          	mov    0x38(%rax),%r13d
    1d51:	48 c1 fa 06          	sar    $0x6,%rdx
	return page_address(skb_frag_page(frag)) + skb_frag_off(frag);
    1d55:	8b 40 3c             	mov    0x3c(%rax),%eax
    1d58:	48 c1 e2 0c          	shl    $0xc,%rdx
    1d5c:	48 03 15 00 00 00 00 	add    0x0(%rip),%rdx        # 1d63 <mlx5e_xdp_xmit+0x403>
    1d63:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
    1d67:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
    1d6e:	4c 8b b0 40 2d 00 00 	mov    0x2d40(%rax),%r14
    1d75:	49 83 fc 10          	cmp    $0x10,%r12
    1d79:	0f 87 89 03 00 00    	ja     2108 <mlx5e_xdp_xmit+0x7a8>
	if (dev_WARN_ONCE(dev, is_vmalloc_addr(ptr),
    1d7f:	48 89 df             	mov    %rbx,%rdi
    1d82:	e8 00 00 00 00       	call   1d87 <mlx5e_xdp_xmit+0x427>
    1d87:	84 c0                	test   %al,%al
    1d89:	0f 84 1a ff ff ff    	je     1ca9 <mlx5e_xdp_xmit+0x349>
    1d8f:	44 0f b6 2d 00 00 00 	movzbl 0x0(%rip),%r13d        # 1d97 <mlx5e_xdp_xmit+0x437>
    1d96:	00 
    1d97:	4c 89 e0             	mov    %r12,%rax
    1d9a:	4d 89 f1             	mov    %r14,%r9
    1d9d:	45 89 fc             	mov    %r15d,%r12d
    1da0:	48 8b 9d 10 ff ff ff 	mov    -0xf0(%rbp),%rbx
    1da7:	44 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%r14d
    1dae:	49 89 c7             	mov    %rax,%r15
    1db1:	41 80 fd 01          	cmp    $0x1,%r13b
    1db5:	0f 87 00 00 00 00    	ja     1dbb <mlx5e_xdp_xmit+0x45b>
    1dbb:	41 83 e5 01          	and    $0x1,%r13d
    1dbf:	0f 84 fc 00 00 00    	je     1ec1 <mlx5e_xdp_xmit+0x561>
    1dc5:	4a c7 84 fd 48 ff ff 	movq   $0xffffffffffffffff,-0xb8(%rbp,%r15,8)
    1dcc:	ff ff ff ff ff 
				if (!dma_mapping_error(sq->pdev, dma_arr[j]))
    1dd1:	49 83 ff 10          	cmp    $0x10,%r15
    1dd5:	0f 87 c7 03 00 00    	ja     21a2 <mlx5e_xdp_xmit+0x842>
				while (--j >= 0)
    1ddb:	41 83 ec 01          	sub    $0x1,%r12d
    1ddf:	4d 63 ec             	movslq %r12d,%r13
    1de2:	41 83 fc ff          	cmp    $0xffffffff,%r12d
    1de6:	0f 84 d6 fd ff ff    	je     1bc2 <mlx5e_xdp_xmit+0x262>
					dma_unmap_single(sq->pdev, dma_arr[j],
    1dec:	49 63 f5             	movslq %r13d,%rsi
    1def:	4c 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%r15
    1df6:	4d 63 e5             	movslq %r13d,%r12
    1df9:	48 83 fe 11          	cmp    $0x11,%rsi
    1dfd:	0f 87 25 03 00 00    	ja     2128 <mlx5e_xdp_xmit+0x7c8>
	return frag->bv_len;
    1e03:	4c 89 e0             	mov    %r12,%rax
    1e06:	48 c1 e0 04          	shl    $0x4,%rax
    1e0a:	42 8b 54 38 38       	mov    0x38(%rax,%r15,1),%edx
    1e0f:	49 83 fc 10          	cmp    $0x10,%r12
    1e13:	0f 87 20 03 00 00    	ja     2139 <mlx5e_xdp_xmit+0x7d9>
	return dma_unmap_page_attrs(dev, addr, size, dir, attrs);
    1e19:	4a 8b b4 ed 48 ff ff 	mov    -0xb8(%rbp,%r13,8),%rsi
    1e20:	ff 
    1e21:	48 8b bb 40 2d 00 00 	mov    0x2d40(%rbx),%rdi
    1e28:	45 31 c0             	xor    %r8d,%r8d
				while (--j >= 0)
    1e2b:	49 83 ed 01          	sub    $0x1,%r13
    1e2f:	b9 01 00 00 00       	mov    $0x1,%ecx
    1e34:	e8 00 00 00 00       	call   1e39 <mlx5e_xdp_xmit+0x4d9>
    1e39:	41 83 fd ff          	cmp    $0xffffffff,%r13d
    1e3d:	75 ad                	jne    1dec <mlx5e_xdp_xmit+0x48c>
	if (sq->mpwqe.wqe)
    1e3f:	48 83 bb 10 2b 00 00 	cmpq   $0x0,0x2b10(%rbx)
    1e46:	00 
    1e47:	0f 85 7f fd ff ff    	jne    1bcc <mlx5e_xdp_xmit+0x26c>
    1e4d:	e9 86 fd ff ff       	jmp    1bd8 <mlx5e_xdp_xmit+0x278>
			for (j = 0; j < xdptxdf.sinfo->nr_frags; j++)
    1e52:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
    1e59:	80 78 02 00          	cmpb   $0x0,0x2(%rax)
    1e5d:	0f 84 42 fd ff ff    	je     1ba5 <mlx5e_xdp_xmit+0x245>
    1e63:	45 31 ff             	xor    %r15d,%r15d
    1e66:	eb 3f                	jmp    1ea7 <mlx5e_xdp_xmit+0x547>
	u32 i = (*fifo->pc)++ & fifo->mask;
    1e68:	48 8b 93 20 2d 00 00 	mov    0x2d20(%rbx),%rdx
						     { .frame.dma_addr = dma_arr[j] });
    1e6f:	4a 8b 8c f5 48 ff ff 	mov    -0xb8(%rbp,%r14,8),%rcx
    1e76:	ff 
			for (j = 0; j < xdptxdf.sinfo->nr_frags; j++)
    1e77:	41 83 c7 01          	add    $0x1,%r15d
    1e7b:	8b 02                	mov    (%rdx),%eax
    1e7d:	8d 70 01             	lea    0x1(%rax),%esi
    1e80:	89 32                	mov    %esi,(%rdx)
	fifo->xi[i] = xi;
    1e82:	48 8b 93 10 2d 00 00 	mov    0x2d10(%rbx),%rdx
    1e89:	23 83 28 2d 00 00    	and    0x2d28(%rbx),%eax
    1e8f:	48 89 0c c2          	mov    %rcx,(%rdx,%rax,8)
    1e93:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
    1e9a:	0f b6 40 02          	movzbl 0x2(%rax),%eax
    1e9e:	44 39 f8             	cmp    %r15d,%eax
    1ea1:	0f 8e fe fc ff ff    	jle    1ba5 <mlx5e_xdp_xmit+0x245>
						     { .frame.dma_addr = dma_arr[j] });
    1ea7:	4d 63 f7             	movslq %r15d,%r14
    1eaa:	49 83 fe 10          	cmp    $0x10,%r14
    1eae:	76 b8                	jbe    1e68 <mlx5e_xdp_xmit+0x508>
    1eb0:	4c 89 f6             	mov    %r14,%rsi
    1eb3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1eba:	e8 00 00 00 00       	call   1ebf <mlx5e_xdp_xmit+0x55f>
    1ebf:	eb a7                	jmp    1e68 <mlx5e_xdp_xmit+0x508>
 * Return: The kobject name of the device, or its initial name if unavailable.
 */
static inline const char *dev_name(const struct device *dev)
{
	/* Use the init name until the kobject becomes available */
	if (dev->init_name)
    1ec1:	4d 8b 69 50          	mov    0x50(%r9),%r13
	if (dev_WARN_ONCE(dev, is_vmalloc_addr(ptr),
    1ec5:	c6 05 00 00 00 00 01 	movb   $0x1,0x0(%rip)        # 1ecc <mlx5e_xdp_xmit+0x56c>
    1ecc:	4d 85 ed             	test   %r13,%r13
    1ecf:	0f 84 af 00 00 00    	je     1f84 <mlx5e_xdp_xmit+0x624>
    1ed5:	4c 89 cf             	mov    %r9,%rdi
    1ed8:	e8 00 00 00 00       	call   1edd <mlx5e_xdp_xmit+0x57d>
    1edd:	4c 89 ea             	mov    %r13,%rdx
    1ee0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1ee7:	48 89 c6             	mov    %rax,%rsi
    1eea:	e8 00 00 00 00       	call   1eef <mlx5e_xdp_xmit+0x58f>
    1eef:	0f 0b                	ud2    
				dma_arr[j] = dma_map_single(sq->pdev, skb_frag_address(frag),
    1ef1:	4a c7 84 fd 48 ff ff 	movq   $0xffffffffffffffff,-0xb8(%rbp,%r15,8)
    1ef8:	ff ff ff ff ff 
				if (!dma_mapping_error(sq->pdev, dma_arr[j]))
    1efd:	49 83 ff 10          	cmp    $0x10,%r15
    1f01:	0f 86 d4 fe ff ff    	jbe    1ddb <mlx5e_xdp_xmit+0x47b>
    1f07:	4c 89 fe             	mov    %r15,%rsi
    1f0a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1f11:	e8 00 00 00 00       	call   1f16 <mlx5e_xdp_xmit+0x5b6>
	if (unlikely(dma_addr == DMA_MAPPING_ERROR))
    1f16:	e9 c0 fe ff ff       	jmp    1ddb <mlx5e_xdp_xmit+0x47b>
	if (dev_WARN_ONCE(dev, is_vmalloc_addr(ptr),
    1f1b:	0f b6 05 00 00 00 00 	movzbl 0x0(%rip),%eax        # 1f22 <mlx5e_xdp_xmit+0x5c2>
    1f22:	44 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%r14d
    1f29:	4d 89 fc             	mov    %r15,%r12
    1f2c:	41 89 c5             	mov    %eax,%r13d
    1f2f:	41 83 e5 01          	and    $0x1,%r13d
    1f33:	3c 01                	cmp    $0x1,%al
    1f35:	0f 87 00 00 00 00    	ja     1f3b <mlx5e_xdp_xmit+0x5db>
    1f3b:	45 84 ed             	test   %r13b,%r13b
    1f3e:	0f 85 7e fc ff ff    	jne    1bc2 <mlx5e_xdp_xmit+0x262>
    1f44:	4d 8b 6c 24 50       	mov    0x50(%r12),%r13
    1f49:	c6 05 00 00 00 00 01 	movb   $0x1,0x0(%rip)        # 1f50 <mlx5e_xdp_xmit+0x5f0>
    1f50:	4d 85 ed             	test   %r13,%r13
    1f53:	74 37                	je     1f8c <mlx5e_xdp_xmit+0x62c>
    1f55:	4c 89 e7             	mov    %r12,%rdi
    1f58:	e8 00 00 00 00       	call   1f5d <mlx5e_xdp_xmit+0x5fd>
    1f5d:	4c 89 ea             	mov    %r13,%rdx
    1f60:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1f67:	48 89 c6             	mov    %rax,%rsi
    1f6a:	e8 00 00 00 00       	call   1f6f <mlx5e_xdp_xmit+0x60f>
    1f6f:	0f 0b                	ud2    
	if (sq->mpwqe.wqe)
    1f71:	48 83 bb 10 2b 00 00 	cmpq   $0x0,0x2b10(%rbx)
    1f78:	00 
    1f79:	0f 85 4d fc ff ff    	jne    1bcc <mlx5e_xdp_xmit+0x26c>
    1f7f:	e9 54 fc ff ff       	jmp    1bd8 <mlx5e_xdp_xmit+0x278>
__printf(2, 3) int kobject_set_name(struct kobject *kobj, const char *name, ...);
__printf(2, 0) int kobject_set_name_vargs(struct kobject *kobj, const char *fmt, va_list vargs);

static inline const char *kobject_name(const struct kobject *kobj)
{
	return kobj->name;
    1f84:	4d 8b 29             	mov    (%r9),%r13
		return dev->init_name;

	return kobject_name(&dev->kobj);
    1f87:	e9 49 ff ff ff       	jmp    1ed5 <mlx5e_xdp_xmit+0x575>
    1f8c:	4d 8b 2c 24          	mov    (%r12),%r13
    1f90:	eb c3                	jmp    1f55 <mlx5e_xdp_xmit+0x5f5>
		ret = INDIRECT_CALL_2(sq->xmit_xdp_frame, mlx5e_xmit_xdp_frame_mpwqe,
    1f92:	48 3d 00 00 00 00    	cmp    $0x0,%rax
    1f98:	0f 85 23 01 00 00    	jne    20c1 <mlx5e_xdp_xmit+0x761>
    1f9e:	e8 00 00 00 00       	call   1fa3 <mlx5e_xdp_xmit+0x643>
    1fa3:	4c 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%r10
		if (unlikely(!ret)) {
    1faa:	84 c0                	test   %al,%al
    1fac:	0f 85 7e fb ff ff    	jne    1b30 <mlx5e_xdp_xmit+0x1d0>
			dma_unmap_single(sq->pdev, xdptxd->dma_addr,
    1fb2:	8b 95 30 ff ff ff    	mov    -0xd0(%rbp),%edx
	return dma_unmap_page_attrs(dev, addr, size, dir, attrs);
    1fb8:	48 8b bb 40 2d 00 00 	mov    0x2d40(%rbx),%rdi
    1fbf:	45 31 c0             	xor    %r8d,%r8d
    1fc2:	b9 01 00 00 00       	mov    $0x1,%ecx
    1fc7:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
    1fce:	44 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%r14d
    1fd5:	81 e2 ff ff ff 7f    	and    $0x7fffffff,%edx
    1fdb:	e8 00 00 00 00       	call   1fe0 <mlx5e_xdp_xmit+0x680>
			if (!xdptxd->has_frags)
    1fe0:	80 bd 33 ff ff ff 00 	cmpb   $0x0,-0xcd(%rbp)
    1fe7:	0f 89 d5 fb ff ff    	jns    1bc2 <mlx5e_xdp_xmit+0x262>
			for (j = 0; j < xdptxdf.sinfo->nr_frags; j++)
    1fed:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
    1ff4:	80 78 02 00          	cmpb   $0x0,0x2(%rax)
    1ff8:	0f 84 c4 fb ff ff    	je     1bc2 <mlx5e_xdp_xmit+0x262>
    1ffe:	45 31 ed             	xor    %r13d,%r13d
    2001:	49 89 c7             	mov    %rax,%r15
				dma_unmap_single(sq->pdev, dma_arr[j],
    2004:	4d 63 e5             	movslq %r13d,%r12
    2007:	49 83 fc 11          	cmp    $0x11,%r12
    200b:	0f 87 7d 01 00 00    	ja     218e <mlx5e_xdp_xmit+0x82e>
    2011:	4c 89 e2             	mov    %r12,%rdx
    2014:	48 c1 e2 04          	shl    $0x4,%rdx
    2018:	42 8b 54 3a 38       	mov    0x38(%rdx,%r15,1),%edx
    201d:	49 83 fc 10          	cmp    $0x10,%r12
    2021:	0f 87 45 01 00 00    	ja     216c <mlx5e_xdp_xmit+0x80c>
    2027:	4a 8b b4 e5 48 ff ff 	mov    -0xb8(%rbp,%r12,8),%rsi
    202e:	ff 
    202f:	48 8b bb 40 2d 00 00 	mov    0x2d40(%rbx),%rdi
    2036:	45 31 c0             	xor    %r8d,%r8d
			for (j = 0; j < xdptxdf.sinfo->nr_frags; j++)
    2039:	41 83 c5 01          	add    $0x1,%r13d
    203d:	b9 01 00 00 00       	mov    $0x1,%ecx
    2042:	e8 00 00 00 00       	call   2047 <mlx5e_xdp_xmit+0x6e7>
    2047:	4c 8b bd 38 ff ff ff 	mov    -0xc8(%rbp),%r15
    204e:	41 0f b6 57 02       	movzbl 0x2(%r15),%edx
    2053:	44 39 ea             	cmp    %r13d,%edx
    2056:	7f ac                	jg     2004 <mlx5e_xdp_xmit+0x6a4>
    2058:	e9 65 fb ff ff       	jmp    1bc2 <mlx5e_xdp_xmit+0x262>
    205d:	48 8b 9d 10 ff ff ff 	mov    -0xf0(%rbp),%rbx
    2064:	4c 8b ad 08 ff ff ff 	mov    -0xf8(%rbp),%r13
    206b:	4c 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%r10
    2072:	44 8b a5 f8 fe ff ff 	mov    -0x108(%rbp),%r12d
    2079:	e9 72 fa ff ff       	jmp    1af0 <mlx5e_xdp_xmit+0x190>
		return -ENETDOWN;
    207e:	41 be 9c ff ff ff    	mov    $0xffffff9c,%r14d
    2084:	e9 59 fb ff ff       	jmp    1be2 <mlx5e_xdp_xmit+0x282>
		return -EINVAL;
    2089:	41 be ea ff ff ff    	mov    $0xffffffea,%r14d
    208f:	e9 4e fb ff ff       	jmp    1be2 <mlx5e_xdp_xmit+0x282>
		return -ENXIO;
    2094:	41 be fa ff ff ff    	mov    $0xfffffffa,%r14d
    209a:	e9 43 fb ff ff       	jmp    1be2 <mlx5e_xdp_xmit+0x282>
    209f:	48 8b 9d 10 ff ff ff 	mov    -0xf0(%rbp),%rbx
    20a6:	44 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%r14d
    20ad:	45 89 fc             	mov    %r15d,%r12d
    20b0:	e9 26 fd ff ff       	jmp    1ddb <mlx5e_xdp_xmit+0x47b>
    20b5:	44 8b b5 18 ff ff ff 	mov    -0xe8(%rbp),%r14d
    20bc:	e9 01 fb ff ff       	jmp    1bc2 <mlx5e_xdp_xmit+0x262>
		ret = INDIRECT_CALL_2(sq->xmit_xdp_frame, mlx5e_xmit_xdp_frame_mpwqe,
    20c1:	e8 00 00 00 00       	call   20c6 <mlx5e_xdp_xmit+0x766>
    20c6:	4c 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%r10
    20cd:	e9 56 fa ff ff       	jmp    1b28 <mlx5e_xdp_xmit+0x1c8>
				skb_frag_t *frag = &xdptxdf.sinfo->frags[j];
    20d2:	4c 89 e6             	mov    %r12,%rsi
    20d5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    20dc:	e8 00 00 00 00       	call   20e1 <mlx5e_xdp_xmit+0x781>
    20e1:	e9 52 fc ff ff       	jmp    1d38 <mlx5e_xdp_xmit+0x3d8>
				if (!dma_mapping_error(sq->pdev, dma_arr[j]))
    20e6:	4c 89 e6             	mov    %r12,%rsi
    20e9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    20f0:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
    20f7:	e8 00 00 00 00       	call   20fc <mlx5e_xdp_xmit+0x79c>
    20fc:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
    2103:	e9 00 fc ff ff       	jmp    1d08 <mlx5e_xdp_xmit+0x3a8>
				dma_arr[j] = dma_map_single(sq->pdev, skb_frag_address(frag),
    2108:	4c 89 e6             	mov    %r12,%rsi
    210b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2112:	e8 00 00 00 00       	call   2117 <mlx5e_xdp_xmit+0x7b7>
    2117:	e9 63 fc ff ff       	jmp    1d7f <mlx5e_xdp_xmit+0x41f>
    211c:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 2123 <mlx5e_xdp_xmit+0x7c3>
    2123:	e9 a5 fb ff ff       	jmp    1ccd <mlx5e_xdp_xmit+0x36d>
					dma_unmap_single(sq->pdev, dma_arr[j],
    2128:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    212f:	e8 00 00 00 00       	call   2134 <mlx5e_xdp_xmit+0x7d4>
    2134:	e9 ca fc ff ff       	jmp    1e03 <mlx5e_xdp_xmit+0x4a3>
    2139:	4c 89 e6             	mov    %r12,%rsi
    213c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2143:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
    214a:	e8 00 00 00 00       	call   214f <mlx5e_xdp_xmit+0x7ef>
    214f:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
    2156:	e9 be fc ff ff       	jmp    1e19 <mlx5e_xdp_xmit+0x4b9>
    215b:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 2162 <mlx5e_xdp_xmit+0x802>
    2162:	e9 37 f9 ff ff       	jmp    1a9e <mlx5e_xdp_xmit+0x13e>
}
    2167:	e8 00 00 00 00       	call   216c <mlx5e_xdp_xmit+0x80c>
				dma_unmap_single(sq->pdev, dma_arr[j],
    216c:	4c 89 e6             	mov    %r12,%rsi
    216f:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2176:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
    217d:	e8 00 00 00 00       	call   2182 <mlx5e_xdp_xmit+0x822>
    2182:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
    2189:	e9 99 fe ff ff       	jmp    2027 <mlx5e_xdp_xmit+0x6c7>
    218e:	4c 89 e6             	mov    %r12,%rsi
    2191:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2198:	e8 00 00 00 00       	call   219d <mlx5e_xdp_xmit+0x83d>
    219d:	e9 6f fe ff ff       	jmp    2011 <mlx5e_xdp_xmit+0x6b1>
				if (!dma_mapping_error(sq->pdev, dma_arr[j]))
    21a2:	4c 89 fe             	mov    %r15,%rsi
    21a5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    21ac:	e8 00 00 00 00       	call   21b1 <mlx5e_xdp_xmit+0x851>
	if (unlikely(dma_addr == DMA_MAPPING_ERROR))
    21b1:	e9 25 fc ff ff       	jmp    1ddb <mlx5e_xdp_xmit+0x47b>
    21b6:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    21bd:	00 00 00 
    21c0:	90                   	nop
    21c1:	90                   	nop
    21c2:	90                   	nop
    21c3:	90                   	nop
    21c4:	90                   	nop
    21c5:	90                   	nop
    21c6:	90                   	nop
    21c7:	90                   	nop
    21c8:	90                   	nop
    21c9:	90                   	nop
    21ca:	90                   	nop
    21cb:	90                   	nop
    21cc:	90                   	nop
    21cd:	90                   	nop
    21ce:	90                   	nop
    21cf:	90                   	nop

00000000000021d0 <mlx5e_xdp_rx_poll_complete>:

void mlx5e_xdp_rx_poll_complete(struct mlx5e_rq *rq)
{
    21d0:	f3 0f 1e fa          	endbr64 
    21d4:	e8 00 00 00 00       	call   21d9 <mlx5e_xdp_rx_poll_complete+0x9>
    21d9:	55                   	push   %rbp
    21da:	48 89 e5             	mov    %rsp,%rbp
    21dd:	41 54                	push   %r12
    21df:	49 89 fc             	mov    %rdi,%r12
    21e2:	53                   	push   %rbx
	struct mlx5e_xdpsq *xdpsq = rq->xdpsq;
    21e3:	48 8b 9f 50 04 00 00 	mov    0x450(%rdi),%rbx

	if (xdpsq->mpwqe.wqe)
    21ea:	48 83 7b 50 00       	cmpq   $0x0,0x50(%rbx)
    21ef:	74 08                	je     21f9 <mlx5e_xdp_rx_poll_complete+0x29>
		mlx5e_xdp_mpwqe_complete(xdpsq);
    21f1:	48 89 df             	mov    %rbx,%rdi
    21f4:	e8 00 00 00 00       	call   21f9 <mlx5e_xdp_rx_poll_complete+0x29>
	if (sq->doorbell_cseg) {
    21f9:	48 8b 53 48          	mov    0x48(%rbx),%rdx
    21fd:	48 85 d2             	test   %rdx,%rdx
    2200:	74 2b                	je     222d <mlx5e_xdp_rx_poll_complete+0x5d>
		mlx5e_notify_hw(&sq->wq, sq->pc, sq->uar_map, sq->doorbell_cseg);
    2202:	48 8b 8b 70 02 00 00 	mov    0x270(%rbx),%rcx
    2209:	0f b7 43 44          	movzwl 0x44(%rbx),%eax
	ctrl->fm_ce_se |= MLX5_WQE_CTRL_CQ_UPDATE;
    220d:	80 4a 0b 08          	orb    $0x8,0xb(%rdx)
	*wq->db = cpu_to_be32(pc);
    2211:	48 8b b3 20 02 00 00 	mov    0x220(%rbx),%rsi
    2218:	0f c8                	bswap  %eax
    221a:	89 06                	mov    %eax,(%rsi)
	wmb();
    221c:	0f ae f8             	sfence 
    221f:	48 8b 02             	mov    (%rdx),%rax
    2222:	48 89 01             	mov    %rax,(%rcx)
		sq->doorbell_cseg = NULL;
    2225:	48 c7 43 48 00 00 00 	movq   $0x0,0x48(%rbx)
    222c:	00 
    222d:	49 8b 84 24 58 04 00 	mov    0x458(%r12),%rax
    2234:	00 

	mlx5e_xmit_xdp_doorbell(xdpsq);

	if (test_bit(MLX5E_RQ_FLAG_XDP_REDIRECT, rq->flags)) {
    2235:	a8 02                	test   $0x2,%al
    2237:	75 09                	jne    2242 <mlx5e_xdp_rx_poll_complete+0x72>
		xdp_do_flush();
		__clear_bit(MLX5E_RQ_FLAG_XDP_REDIRECT, rq->flags);
	}
}
    2239:	5b                   	pop    %rbx
    223a:	41 5c                	pop    %r12
    223c:	5d                   	pop    %rbp
    223d:	e9 00 00 00 00       	jmp    2242 <mlx5e_xdp_rx_poll_complete+0x72>
		xdp_do_flush();
    2242:	e8 00 00 00 00       	call   2247 <mlx5e_xdp_rx_poll_complete+0x77>
	asm volatile(__ASM_SIZE(btr) " %1,%0" : : ADDR, "Ir" (nr) : "memory");
    2247:	49 0f ba b4 24 58 04 	btrq   $0x1,0x458(%r12)
    224e:	00 00 01 
}
    2251:	5b                   	pop    %rbx
    2252:	41 5c                	pop    %r12
    2254:	5d                   	pop    %rbp
    2255:	e9 00 00 00 00       	jmp    225a <mlx5e_xdp_rx_poll_complete+0x8a>
    225a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    2260:	90                   	nop
    2261:	90                   	nop
    2262:	90                   	nop
    2263:	90                   	nop
    2264:	90                   	nop
    2265:	90                   	nop
    2266:	90                   	nop
    2267:	90                   	nop
    2268:	90                   	nop
    2269:	90                   	nop
    226a:	90                   	nop
    226b:	90                   	nop
    226c:	90                   	nop
    226d:	90                   	nop
    226e:	90                   	nop
    226f:	90                   	nop

0000000000002270 <mlx5e_set_xmit_fp>:

void mlx5e_set_xmit_fp(struct mlx5e_xdpsq *sq, bool is_mpw)
{
    2270:	f3 0f 1e fa          	endbr64 
    2274:	e8 00 00 00 00       	call   2279 <mlx5e_set_xmit_fp+0x9>
	sq->xmit_xdp_frame_check = is_mpw ?
    2279:	40 84 f6             	test   %sil,%sil
    227c:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
    2283:	48 c7 c2 00 00 00 00 	mov    $0x0,%rdx
{
    228a:	55                   	push   %rbp
	sq->xmit_xdp_frame_check = is_mpw ?
    228b:	48 0f 45 d0          	cmovne %rax,%rdx
    228f:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
    2296:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
    229d:	48 0f 45 c1          	cmovne %rcx,%rax
{
    22a1:	48 89 e5             	mov    %rsp,%rbp
    22a4:	48 89 97 38 02 00 00 	mov    %rdx,0x238(%rdi)
		mlx5e_xmit_xdp_frame_check_mpwqe : mlx5e_xmit_xdp_frame_check;
	sq->xmit_xdp_frame = is_mpw ?
		mlx5e_xmit_xdp_frame_mpwqe : mlx5e_xmit_xdp_frame;
}
    22ab:	5d                   	pop    %rbp
	sq->xmit_xdp_frame = is_mpw ?
    22ac:	48 89 87 40 02 00 00 	mov    %rax,0x240(%rdi)
}
    22b3:	e9 00 00 00 00       	jmp    22b8 <mlx5e_set_xmit_fp+0x48>

Disassembly of section .text.unlikely:

0000000000000000 <mlx5e_xdpsq_get_next_pi.cold>:
	frag = ix >> fbc->log_frag_strides;
   0:	44 89 e8             	mov    %r13d,%eax
   3:	0f b6 d1             	movzbl %cl,%edx
   6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
   d:	88 4d d4             	mov    %cl,-0x2c(%rbp)
  10:	48 89 c6             	mov    %rax,%rsi
  13:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  17:	e8 00 00 00 00       	call   1c <mlx5e_xdpsq_get_next_pi.cold+0x1c>
  1c:	0f b6 4d d4          	movzbl -0x2c(%rbp),%ecx
  20:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
  24:	44 0f b7 0d 00 00 00 	movzwl 0x0(%rip),%r9d        # 2c <mlx5e_xdpsq_get_next_pi.cold+0x2c>
  2b:	00 
  2c:	e9 00 00 00 00       	jmp    31 <mlx5e_xdpsq_get_next_pi.cold+0x31>
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
  31:	0f b6 d1             	movzbl %cl,%edx
  34:	89 c6                	mov    %eax,%esi
  36:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  3d:	44 89 55 d0          	mov    %r10d,-0x30(%rbp)
  41:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  45:	88 4d c8             	mov    %cl,-0x38(%rbp)
  48:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  4b:	e8 00 00 00 00       	call   50 <mlx5e_xdpsq_get_next_pi.cold+0x50>
  50:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  53:	0f b6 4d c8          	movzbl -0x38(%rbp),%ecx
  57:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  5b:	44 8b 55 d0          	mov    -0x30(%rbp),%r10d
  5f:	44 0f b7 0d 00 00 00 	movzwl 0x0(%rip),%r9d        # 67 <mlx5e_xdpsq_get_next_pi.cold+0x67>
  66:	00 
  67:	e9 00 00 00 00       	jmp    6c <mlx5e_xmit_xdp_frame.cold>

000000000000006c <mlx5e_xmit_xdp_frame.cold>:
	frag = ix >> fbc->log_frag_strides;
  6c:	44 89 d8             	mov    %r11d,%eax
  6f:	0f b6 d1             	movzbl %cl,%edx
  72:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  79:	88 4d b0             	mov    %cl,-0x50(%rbp)
  7c:	48 89 c6             	mov    %rax,%rsi
  7f:	44 89 4d a8          	mov    %r9d,-0x58(%rbp)
  83:	44 89 55 a0          	mov    %r10d,-0x60(%rbp)
  87:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8b:	44 89 5d d0          	mov    %r11d,-0x30(%rbp)
  8f:	e8 00 00 00 00       	call   94 <mlx5e_xmit_xdp_frame.cold+0x28>
  94:	44 8b 5d d0          	mov    -0x30(%rbp),%r11d
  98:	0f b6 4d b0          	movzbl -0x50(%rbp),%ecx
  9c:	44 8b 45 ac          	mov    -0x54(%rbp),%r8d
  a0:	44 8b 55 a0          	mov    -0x60(%rbp),%r10d
  a4:	44 8b 4d a8          	mov    -0x58(%rbp),%r9d
  a8:	e9 00 00 00 00       	jmp    ad <mlx5e_xmit_xdp_frame.cold+0x41>
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
  ad:	0f b6 d1             	movzbl %cl,%edx
  b0:	44 89 ee             	mov    %r13d,%esi
  b3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  ba:	89 45 a8             	mov    %eax,-0x58(%rbp)
  bd:	44 89 4d a0          	mov    %r9d,-0x60(%rbp)
  c1:	44 89 55 ac          	mov    %r10d,-0x54(%rbp)
  c5:	44 89 45 b0          	mov    %r8d,-0x50(%rbp)
  c9:	88 4d d0             	mov    %cl,-0x30(%rbp)
  cc:	e8 00 00 00 00       	call   d1 <mlx5e_xmit_xdp_frame.cold+0x65>
  d1:	0f b6 4d d0          	movzbl -0x30(%rbp),%ecx
  d5:	44 8b 45 b0          	mov    -0x50(%rbp),%r8d
  d9:	44 8b 55 ac          	mov    -0x54(%rbp),%r10d
  dd:	44 8b 4d a0          	mov    -0x60(%rbp),%r9d
  e1:	8b 45 a8             	mov    -0x58(%rbp),%eax
  e4:	e9 00 00 00 00       	jmp    e9 <mlx5e_xmit_xdp_frame_mpwqe.cold>

00000000000000e9 <mlx5e_xmit_xdp_frame_mpwqe.cold>:
  e9:	0f b6 d1             	movzbl %cl,%edx
  ec:	89 c6                	mov    %eax,%esi
  ee:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  f5:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  f9:	88 4d af             	mov    %cl,-0x51(%rbp)
  fc:	89 45 b0             	mov    %eax,-0x50(%rbp)
  ff:	e8 00 00 00 00       	call   104 <mlx5e_xmit_xdp_frame_mpwqe.cold+0x1b>
 104:	8b 45 b0             	mov    -0x50(%rbp),%eax
 107:	0f b6 4d af          	movzbl -0x51(%rbp),%ecx
 10b:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
 10f:	e9 00 00 00 00       	jmp    114 <mlx5e_xmit_xdp_frame_mpwqe.cold+0x2b>
	frag = ix >> fbc->log_frag_strides;
 114:	44 89 c8             	mov    %r9d,%eax
 117:	0f b6 d1             	movzbl %cl,%edx
 11a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 121:	88 4d af             	mov    %cl,-0x51(%rbp)
 124:	48 89 c6             	mov    %rax,%rsi
 127:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
 12b:	44 89 4d b0          	mov    %r9d,-0x50(%rbp)
 12f:	e8 00 00 00 00       	call   134 <mlx5e_xmit_xdp_frame_mpwqe.cold+0x4b>
 134:	44 8b 4d b0          	mov    -0x50(%rbp),%r9d
 138:	0f b6 4d af          	movzbl -0x51(%rbp),%ecx
 13c:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
 140:	e9 00 00 00 00       	jmp    145 <mlx5e_poll_xdpsq_cq.cold>

0000000000000145 <mlx5e_poll_xdpsq_cq.cold>:
	WARN_ONCE(1, "%s: unknown reg_state %d\n", dev->name, dev->reg_state);
 145:	0f b6 f2             	movzbl %dl,%esi
 148:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 14f:	4c 89 9d 00 ff ff ff 	mov    %r11,-0x100(%rbp)
 156:	44 88 8d 18 ff ff ff 	mov    %r9b,-0xe8(%rbp)
 15d:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
 164:	88 95 30 ff ff ff    	mov    %dl,-0xd0(%rbp)
 16a:	e8 00 00 00 00       	call   16f <mlx5e_poll_xdpsq_cq.cold+0x2a>
 16f:	0f b6 95 30 ff ff ff 	movzbl -0xd0(%rbp),%edx
 176:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
 17d:	44 0f b6 8d 18 ff ff 	movzbl -0xe8(%rbp),%r9d
 184:	ff 
 185:	4c 8b 9d 00 ff ff ff 	mov    -0x100(%rbp),%r11
 18c:	e9 00 00 00 00       	jmp    191 <mlx5e_poll_xdpsq_cq.cold+0x4c>
 191:	44 89 f0             	mov    %r14d,%eax
 194:	0f b6 d1             	movzbl %cl,%edx
 197:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 19e:	88 8d 30 ff ff ff    	mov    %cl,-0xd0(%rbp)
 1a4:	48 89 c6             	mov    %rax,%rsi
 1a7:	e8 00 00 00 00       	call   1ac <mlx5e_poll_xdpsq_cq.cold+0x67>
 1ac:	0f b6 8d 30 ff ff ff 	movzbl -0xd0(%rbp),%ecx
 1b3:	e9 00 00 00 00       	jmp    1b8 <mlx5e_poll_xdpsq_cq.cold+0x73>
			netdev_WARN_ONCE(sq->channel->netdev,
 1b8:	0f b6 f0             	movzbl %al,%esi
 1bb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 1c2:	4c 89 9d 28 ff ff ff 	mov    %r11,-0xd8(%rbp)
 1c9:	88 85 30 ff ff ff    	mov    %al,-0xd0(%rbp)
 1cf:	e8 00 00 00 00       	call   1d4 <mlx5e_poll_xdpsq_cq.cold+0x8f>
 1d4:	4c 8b 9d 28 ff ff ff 	mov    -0xd8(%rbp),%r11
 1db:	0f b6 85 30 ff ff ff 	movzbl -0xd0(%rbp),%eax
 1e2:	45 0f b6 4b 3f       	movzbl 0x3f(%r11),%r9d
 1e7:	41 c0 e9 04          	shr    $0x4,%r9b
 1eb:	e9 00 00 00 00       	jmp    1f0 <mlx5e_poll_xdpsq_cq.cold+0xab>
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
 1f0:	44 89 f8             	mov    %r15d,%eax
 1f3:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 1fa:	89 8d 30 ff ff ff    	mov    %ecx,-0xd0(%rbp)
 200:	48 89 c6             	mov    %rax,%rsi
 203:	e8 00 00 00 00       	call   208 <mlx5e_poll_xdpsq_cq.cold+0xc3>
	cqe += wq->fbc.log_stride == 7;
 208:	0f b6 53 11          	movzbl 0x11(%rbx),%edx
 20c:	8b 8d 30 ff ff ff    	mov    -0xd0(%rbp),%ecx
 212:	e9 00 00 00 00       	jmp    217 <mlx5e_poll_xdpsq_cq.cold+0xd2>
	frag = ix >> fbc->log_frag_strides;
 217:	0f b6 d1             	movzbl %cl,%edx
 21a:	89 c6                	mov    %eax,%esi
 21c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 223:	88 8d 28 ff ff ff    	mov    %cl,-0xd8(%rbp)
 229:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%rbp)
 22f:	e8 00 00 00 00       	call   234 <mlx5e_poll_xdpsq_cq.cold+0xef>
 234:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
 23a:	0f b6 8d 28 ff ff ff 	movzbl -0xd8(%rbp),%ecx
 241:	e9 00 00 00 00       	jmp    246 <mlx5e_poll_xdpsq_cq.cold+0x101>
	return ctr >> wq->fbc.log_sz;
 246:	44 89 e8             	mov    %r13d,%eax
 249:	0f b6 d1             	movzbl %cl,%edx
 24c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 253:	4c 89 9d 28 ff ff ff 	mov    %r11,-0xd8(%rbp)
 25a:	48 89 c6             	mov    %rax,%rsi
 25d:	88 8d 30 ff ff ff    	mov    %cl,-0xd0(%rbp)
 263:	e8 00 00 00 00       	call   268 <mlx5e_poll_xdpsq_cq.cold+0x123>
 268:	0f b6 8d 30 ff ff ff 	movzbl -0xd0(%rbp),%ecx
 26f:	4c 8b 9d 28 ff ff ff 	mov    -0xd8(%rbp),%r11
 276:	e9 00 00 00 00       	jmp    27b <mlx5e_poll_xdpsq_cq.cold+0x136>
 27b:	0f b6 d1             	movzbl %cl,%edx
 27e:	44 89 e6             	mov    %r12d,%esi
 281:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 288:	88 85 20 ff ff ff    	mov    %al,-0xe0(%rbp)
 28e:	4c 89 9d 28 ff ff ff 	mov    %r11,-0xd8(%rbp)
 295:	88 8d 30 ff ff ff    	mov    %cl,-0xd0(%rbp)
 29b:	e8 00 00 00 00       	call   2a0 <mlx5e_poll_xdpsq_cq.cold+0x15b>
 2a0:	0f b6 8d 30 ff ff ff 	movzbl -0xd0(%rbp),%ecx
 2a7:	4c 8b 9d 28 ff ff ff 	mov    -0xd8(%rbp),%r11
 2ae:	0f b6 85 20 ff ff ff 	movzbl -0xe0(%rbp),%eax
 2b5:	e9 00 00 00 00       	jmp    2ba <mlx5e_poll_xdpsq_cq.cold+0x175>
	return fbc->frags[frag].buf + ((fbc->frag_sz_m1 & ix) << fbc->log_stride);
 2ba:	44 89 f0             	mov    %r14d,%eax
 2bd:	0f b6 d1             	movzbl %cl,%edx
 2c0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 2c7:	89 8d 30 ff ff ff    	mov    %ecx,-0xd0(%rbp)
 2cd:	48 89 c6             	mov    %rax,%rsi
 2d0:	e8 00 00 00 00       	call   2d5 <mlx5e_poll_xdpsq_cq.cold+0x190>
	cqe += wq->fbc.log_stride == 7;
 2d5:	0f b6 43 11          	movzbl 0x11(%rbx),%eax
 2d9:	8b 8d 30 ff ff ff    	mov    -0xd0(%rbp),%ecx
 2df:	e9 00 00 00 00       	jmp    2e4 <mlx5e_xdp_xmit.cold>

00000000000002e4 <mlx5e_xdp_xmit.cold>:
	if (dev_WARN_ONCE(dev, is_vmalloc_addr(ptr),
 2e4:	0f b6 f0             	movzbl %al,%esi
 2e7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 2ee:	e8 00 00 00 00       	call   2f3 <mlx5e_xdp_xmit.cold+0xf>
 2f3:	45 84 ed             	test   %r13b,%r13b
 2f6:	0f 84 00 00 00 00    	je     2fc <mlx5e_xdp_xmit.cold+0x18>
 2fc:	e9 00 00 00 00       	jmp    301 <mlx5e_xdp_xmit.cold+0x1d>
 301:	41 0f b6 f5          	movzbl %r13b,%esi
 305:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 30c:	4c 89 8d 18 ff ff ff 	mov    %r9,-0xe8(%rbp)
 313:	e8 00 00 00 00       	call   318 <mlx5e_xdp_xmit.cold+0x34>
 318:	4c 8b 8d 18 ff ff ff 	mov    -0xe8(%rbp),%r9
 31f:	e9 00 00 00 00       	jmp    324 <mlx5e_xdp_xmit.cold+0x40>

Disassembly of section .altinstr_replacement:

0000000000000000 <.altinstr_replacement>:
   0:	41 0f 0d 4d 00       	prefetchw 0x0(%r13)
   5:	41 0f 0d 4d 40       	prefetchw 0x40(%r13)
   a:	0f 0d 48 20          	prefetchw 0x20(%rax)
   e:	0f 0d 48 60          	prefetchw 0x60(%rax)
